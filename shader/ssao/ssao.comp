#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_control_flow_attributes : enable

#include "scene.glsl"
#include "common.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

layout(push_constant, std140) uniform PushConstant {
  mat4 proj;
  mat4 projInv;
  };

layout(binding  = 0) uniform writeonly image2D result;
layout(binding  = 1, std140) uniform UboScene {
  SceneDesc scene;
  };

layout(binding  = 2) uniform sampler2D  gbufDiffuse;
layout(binding  = 3) uniform usampler2D gbufNormal;
layout(binding  = 4) uniform sampler2D  depthBuf;

const uint  numSamples     = 32;
const uint  numIter        = 8;
const uint  samplesPerStep = numSamples/numIter;
const float sphereLen      = 100;
const float unorm16        = 65025;

ivec2 fragCoord;
ivec2 screenSize;
mat3  tangent;

float occlusionAll = 0, weightAll = 0;

shared uint shMaxSteps;

shared uint vAvg, vDiff;
bool isSolved(float occlusion, int samples, bool eval) {
  vAvg  = 0;
  vDiff = 0;
  barrier();

  if(occlusion>0) {
    uint v = uint(occlusion*unorm16);
    atomicAdd(vAvg, v);
    }
  barrier();

  if(eval) {
    float avg  = float(vAvg)/float(gl_WorkGroupSize.x*gl_WorkGroupSize.y*unorm16);
    float diff = abs(occlusion - avg);
    atomicMax(vDiff, floatBitsToUint(diff));
    }
  barrier();

  float diff = uintBitsToFloat(vDiff);
  float th   = 0.0;
  if(samples>=12)
    th = 0.1;
  if(samples>=16)
    th = 0.2;
  if(samples>=24)
    th = 0.4;
  return diff<=th;
  }

int estimateMaxSteps(float z) {
  if(z>=1.0)
    return 0; // sky
  if(z>=0.999)
    return 1; // almost sky
  return int(numIter);
  }

shared vec3 shNormal;
int estimateMinSteps(vec3 n) {
  if(gl_LocalInvocationID.xy==uvec2(4)) {
    shNormal = n;
    }
  vDiff = 4;
  barrier();

  if(dot(shNormal, n)<0.99)
    vDiff = 8;
  barrier();

  return int(vDiff);
  }

vec3 unproject(vec3 pos) {
  return projectiveUnproject(projInv, pos);
  }

vec3 project(vec3 pos) {
  return projectiveProject(proj, pos);
  }

float readZ(in vec2 posf) {
  return textureLod(depthBuf, posf.xy*0.5+vec2(0.5), 0).r;
  }

float sampleRadius(uint i, uint maxSmp) {
  return 0.5+float(i)/float(maxSmp);
  }

void calcOcclussion(const vec3 at0, const vec3 pos0, const float f0, uint seed, uint step) {
  [[loop]]
  for(uint i0=0; i0<samplesPerStep; ++i0) {
    uint  i      = i0*step + seed;
    float r      = sampleRadius(i,numSamples);
    vec3  h      = sampleHemisphereCos(i,numSamples,f0).xzy;

    vec3  v      = tangent * h;
    vec3  at1    = project(pos0 + v*sphereLen*r);
    if(abs(at1.x)>1.0 || abs(at1.y)>1.0) {
      continue;
      }

    float z      = readZ(at1.xy);
    bool  isHit  = floor(z*32768.0+0.5) < floor(at1.z*32768.0);
    float distQ  = 1;
    float u      = 0.5;

    // distance attenuation
    if(isHit) {
      vec3  at2  = vec3(at1.xy,z);
      vec3  pos2 = unproject(at2);
      vec3  dp   = (pos2.xyz-pos0);
      float lenQ = dot(dp,dp);
      distQ = (lenQ/(sphereLen*sphereLen));
      } else {
      distQ = 1;//(r*r);
      }

    const float distW = (u*r)/max(u*u, distQ);
    if(isHit)
      occlusionAll += distW;
    weightAll += distW;
    }
  }

vec3 reconstructNormal(const vec3 at0, in vec2 uv){
  vec2 uv0 = uv; // center

  vec2 uvL = uv - vec2(2, 0) / vec2(screenSize); // left
  vec2 uvR = uv + vec2(2, 0) / vec2(screenSize); // right
  vec2 uvT = uv - vec2(0, 2) / vec2(screenSize); // top
  vec2 uvB = uv + vec2(0, 2) / vec2(screenSize); // bottom

  const vec3 atL = vec3(uvL.xy,readZ(uvL.xy));
  const vec3 atR = vec3(uvR.xy,readZ(uvR.xy));
  const vec3 atT = vec3(uvT.xy,readZ(uvT.xy));
  const vec3 atB = vec3(uvB.xy,readZ(uvB.xy));

  const bool bestL    = (abs(atL.z - at0.z) < abs(atR.z - at0.z));
  const bool bestT    = (abs(atT.z - at0.z) < abs(atB.z - at0.z));

  const vec3 bestHor  = bestL ? atL : atR;
  const vec3 bestVert = bestT ? atT : atB;

  vec3 P0 = unproject(at0);
  vec3 P1 = unproject(bestHor);
  vec3 P2 = unproject(bestVert);

  vec3 normal = normalize(cross(P2 - P0, P1 - P0));
  if(bestL != bestT)
    return -normal;
  return normal;
  }

void main() {
  shMaxSteps = 0;
  barrier();

  screenSize = ivec2(textureSize(depthBuf,0));
  fragCoord  = ivec2(gl_GlobalInvocationID.xy);

  const bool valid = all(lessThan(fragCoord, screenSize));
  const vec2 inPos = vec2(2*fragCoord+ivec2(1,1))/vec2(screenSize)-vec2(1,1);
  vec3 norm = vec3(0);

  const vec3 camPos = unproject(vec3(0,0,0));
  const vec3 at0    = vec3(inPos.xy,readZ(inPos.xy));
  const vec3 pos0   = unproject(at0);

  if(valid) {
    const vec3 view = (pos0 - camPos);

    // norm = normalFetch(gbufNormal, fragCoord);
    // norm = (scene.view * vec4(norm,0)).xyz;
    norm = reconstructNormal(at0, inPos.xy);

    // Compute a tangent frame and rotate the half vector to world space
    vec3 up   = abs(norm.z) < 0.999f ? vec3(0.0f, 0.0f, 1.0f) : vec3(1.0f, 0.0f, 0.0f);
    tangent[0] = normalize(cross(up, norm));
    tangent[1] = cross(norm, tangent[0]);
    tangent[2] = norm;
    }

  float occlusion = -1, prev = -1;
  vec2  occ       = vec2(0,0.00001);

  const float f0 = M_PI*2.0*interleavedGradientNoise(fragCoord);

  int maxSteps = estimateMaxSteps(at0.z);
  atomicMax(shMaxSteps, maxSteps);
  barrier();

  // maxSteps = int(shMaxSteps);
  int  dbg  = 0;
  int  smp  = int(samplesPerStep);
  int  smin = estimateMinSteps(norm);
  bool eval = valid;
  for(int i=0; i<shMaxSteps; ++i) {
    if(eval && i<maxSteps) {
      dbg       = i+1;
      smp      += int(samplesPerStep);
      prev      = occlusion;

      calcOcclussion(at0, pos0, f0, i, numIter);
      occlusion = (occlusionAll/weightAll);
      }

    int samples = (i+1)*int(samplesPerStep);
    if(samples<smin)
      continue;
    if(isSolved(occlusion,samples,(i<maxSteps)))
      break;
    }

  if(valid) {
    imageStore(result, ivec2(gl_GlobalInvocationID.xy), vec4(2.0*occlusion));

    // imageStore(result, ivec2(gl_GlobalInvocationID.xy), vec4(float(dbg)/10.0));
    // imageStore(result, ivec2(gl_GlobalInvocationID.xy), vec4(float(smp)/100.0));
    // imageStore(result, ivec2(gl_GlobalInvocationID.xy), vec4(uintBitsToFloat(vDiff)));
    }
  }
