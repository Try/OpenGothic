#version 450

#extension GL_EXT_samplerless_texture_functions : enable
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_control_flow_attributes : enable

#include "sky/sky_common.glsl"
#include "scene.glsl"

layout(push_constant, std430) uniform UboPush {
  ivec4 sectors;
  vec2  sunPosition2d;
  } push;

layout(binding = 0, r32ui)  uniform uimage2D  outImage;
layout(binding = 1, std140) uniform UboScene  { SceneDesc scene; };
layout(binding = 2)         uniform texture2D depth;
layout(binding = 3)         uniform sampler2D textureSm1;

layout(binding = 9, rgba8)  uniform image2D   dbgImage;

layout(local_size_x = 64) in;

const uint NumThreads = gl_WorkGroupSize.x*gl_WorkGroupSize.y*gl_WorkGroupSize.z;

vec4 dbgColor = vec4(0);

ivec2 findBand(const vec2 sun2d, const ivec2 isun, const ivec2 viewportSize, int rayID) {
  int bandId = 0;
  if(isun.x>viewportSize.x)
    bandId = (isun.x-viewportSize.x)/int(NumThreads);

  while(true) {
    if(bandId>100)
      ;//break;
    if(isun.x <= NumThreads*bandId)
      return ivec2(bandId, rayID);
    ++bandId;

    const float a   = float(isun.x - int(NumThreads)*bandId)/float(isun.x);
    const vec2  top = mix(vec2(0,0), sun2d, a);
    const vec2  bot = mix(vec2(0,1), sun2d, a);

    int iTop = int(top.y*viewportSize.y);
    int iBot = int(bot.y*viewportSize.y);
    if(iTop>iBot || iBot<0)
      continue;

    int num   = iBot - iTop;
    if(rayID<num)
      return ivec2(bandId, rayID);
    rayID -= num;
    }
  return ivec2(bandId, -1);
  }

ivec2 findFragCoord(const vec2 sun, const ivec2 viewportSize, int iRayID) {
  const uint  laneID = gl_LocalInvocationIndex;

  const vec2  sun2d  = sun*0.5 + 0.5;
  const ivec2 isun   = ivec2(sun2d * viewportSize);

  const ivec2 pkg    = findBand(sun2d, isun, viewportSize, iRayID);
  const int   bandId = pkg.x;
  const int   rayID  = pkg.y;
  if(rayID<0)
    return ivec2(-1);

  dbgColor = vec4(float(laneID)/64.0, float(rayID%64)/64.0, float(bandId%64)/64.0, 0);

  const float aS   = float(isun.x - int(NumThreads)*bandId)/float(isun.x);
  const vec2  atS  = mix(vec2(0,0), sun2d, aS) + vec2(0, rayID)/vec2(viewportSize);

  const float a    = float(laneID)/float(NumThreads*bandId);
  const ivec2 iat  = ivec2(mix(atS, sun2d, a) * viewportSize);

  return iat;
  }

ivec2 findFragCoord(const vec2 sun2d, const ivec2 viewportSize, const ivec4 sectors) {
  int rayID = int(gl_WorkGroupID.x);

  if(rayID<sectors.x) {
    // left
    ivec2 at = findFragCoord(vec2(+sun2d.x, sun2d.y), viewportSize, rayID);
    // return ivec2(-1);
    return at;
    }
  rayID -= sectors.x;

  if(rayID<sectors.y) {
    // bottom
    ivec2 at = findFragCoord(vec2(-sun2d.y, sun2d.x), viewportSize.yx, rayID).yx;
    at.y = viewportSize.y - at.y;
    // return ivec2(-1);
    return at;
    }
  rayID -= sectors.y;

  if(rayID<sectors.z) {
    // right
    ivec2 at = findFragCoord(vec2(-sun2d.x, -sun2d.y), viewportSize, rayID);
    at.x = viewportSize.x - at.x;
    at.y = viewportSize.y - at.y;
    // return ivec2(-1);
    return at;
    }
  rayID -= sectors.z;

  if(rayID<sectors.w) {
    // top
    ivec2 at = findFragCoord(vec2(sun2d.y, -sun2d.x), viewportSize.yx, rayID).yx;
    at.x = viewportSize.x - at.x;
    return at;
    }

  // unreachable
  return ivec2(-1);
  }

shared uint  hiZ;
shared float shadowSamples[1024];

vec3 project(mat4 m, vec3 pos) {
  vec4 p = m*vec4(pos,1);
  return p.xyz/p.w;
  }

float shadowSample(in sampler2D shadowMap, vec2 shPos, float w) {
  if(abs(shPos.x)>=w || abs(shPos.y)>=w)
    return 0;
  shPos.xy = (shPos.xy/w)*vec2(0.5)+vec2(0.5);
  return textureLod(shadowMap,shPos,0).r;
  }

bool shadowFactor(in sampler2D shadowMap, vec4 shPos) {
  if(abs(shPos.x)>=shPos.w || abs(shPos.y)>=shPos.w)
    return true;
  vec3 sh = shPos.xyz/shPos.w;
  sh.xy = (sh.xy)*vec2(0.5)+vec2(0.5);
  return textureLod(shadowMap,sh.xy,0).r < sh.z;
  }

void processFrag(ivec2 fragCoord, bool valid, ivec2 viewportSize) {
  const uint laneID = gl_LocalInvocationIndex;

  hiZ = floatBitsToUint(0.0);
  barrier();

  float z = 0;
  if(valid) {
    z = min(texelFetch(depth, fragCoord, 0).r, dFogMax);
    atomicMax(hiZ, floatBitsToUint(z));
    }
  barrier();

  vec2 inPos = vec2(fragCoord.xy+vec2(0.5))/vec2(viewportSize);
  inPos = inPos*2.0 - vec2(1.0);

  const float hZ    = uintBitsToFloat(hiZ);
  const vec3  pos0  = project(scene.viewProjectLwcInv, vec3(inPos, dFogMin));
  const vec3  pos1  = project(scene.viewProjectLwcInv, vec3(inPos, dFogMax));
  const vec3  posh  = project(scene.viewProjectLwcInv, vec3(inPos, hZ));
  const vec3  posz  = project(scene.viewProjectLwcInv, vec3(inPos, z));

  const vec4  shPos0 = scene.viewShadowLwc[1]*vec4(pos0, 1);
  const vec4  shPos1 = scene.viewShadowLwc[1]*vec4(pos1, 1);
  const vec4  shPosH = scene.viewShadowLwc[1]*vec4(posh, 1);
  const vec4  shPosZ = scene.viewShadowLwc[1]*vec4(posz, 1);

  for(uint i=laneID; i<shadowSamples.length(); i+=NumThreads) {
    const float t     = (i+0.5)/float(shadowSamples.length());
    const vec4  shPos = mix(shPos0, shPos1, t);

    shadowSamples[i] = shadowSample(textureSm1, shPos.xy, shPos.w);
    }
  barrier();

  const float maxTr    = length((shPosZ-shPos0).xyw)/length((shPos1-shPos0).xyw);
  const int   steps    = 32;
  // const float noise    = interleavedGradientNoise(fragCoord)/steps;
  const float noise    = 0;

  uint occlusion = 0;
  for(uint i=0; i<steps; ++i) {
    float t      = (i+0.3)/float(steps);
    vec4  shPos  = mix(shPos0, shPosZ, t+noise);

    float k      = t*maxTr;
    int   sz     = shadowSamples.length();
    float shVal  = shadowSamples[min(int(k*sz), sz-1)];

    bool  shadow = shVal < shPos.z/shPos.w;
    occlusion = occlusion | ((shadow ? 1u : 0u) << uint(i));
    }

  const uint refStp = 256;
  float refOcclusion = 0;
  for(uint i=0; i<refStp; ++i) {
    float t      = (i+0.3)/float(refStp);
    vec4  shPos  = mix(shPos0, shPosZ, t+0);

    float k      = t*maxTr;
    int   sz     = shadowSamples.length();
    float shVal  = shadowSamples[min(int(k*sz), sz-1)];
    //float shVal  = shadowSample(textureSm1, shPos.xy, shPos.w);

    bool  shadow = shVal < shPos.z/shPos.w;
    refOcclusion += shadow ? 0 : 1;
    }

  if(valid) {
    imageStore(dbgImage, fragCoord, vec4(refOcclusion/refStp));
    imageStore(outImage, fragCoord, uvec4(occlusion));
    }
  }

void main() {
  if(int(gl_WorkGroupID.x) >= push.sectors.x)
    ;//return;

  const vec2  sun2d        = push.sunPosition2d;
  const ivec2 viewportSize = textureSize(depth,0);
  const ivec2 at           = findFragCoord(sun2d, viewportSize, push.sectors);
  const bool  valid        = (0<=at.x && 0<=at.y && at.x<viewportSize.x && at.y<viewportSize.y);

  processFrag(at, valid, viewportSize);

  if(valid)
    ;//imageStore(outImage, at, dbgColor);
  }
