#version 450

#extension GL_EXT_control_flow_attributes : enable
#extension GL_GOOGLE_include_directive    : enable

#include "sky_common.glsl"

layout(binding = 0) uniform sampler2D tLUT;
layout(binding = 1) uniform sampler2D mLUT;
layout(binding = 2) uniform sampler2D skyLUT;

layout(binding = 3) uniform writeonly image3D fogLut;

layout(local_size_x = 8, local_size_y = 8) in;

vec3 transmittance(vec3 pos0, vec3 pos1) {
  const int   steps = 32;
  const float scale = 30.0;

  vec3  transmittance = vec3(1.0);
  vec3  dir  = pos1-pos0;
  float dist = length(dir);
  for(int i=1; i<=steps; ++i) {
    float t      = (float(i)/steps);
    float dt     = dist/steps;
    vec3  newPos = pos0 + t*dir + vec3(0,RPlanet,0);

    vec3  rayleighScattering = vec3(0);
    vec3  extinction         = vec3(0);
    float mieScattering      = float(0);
    scatteringValues(newPos, rayleighScattering, mieScattering, extinction);

    transmittance *= exp(-dt*extinction*scale);
    }
  return transmittance;
  }

vec3 raymarchScattering(vec3 pos, vec3 rayDir, vec3 sunDir, float tMax) {
  const int steps = 32;

  float cosTheta = dot(rayDir, sunDir);

  float miePhaseValue      = miePhase(cosTheta);
  float rayleighPhaseValue = rayleighPhase(-cosTheta);

  vec3  lum                = vec3(0.0);
  vec3  transmittance      = vec3(1.0);

  for(int i=1; i<=steps; ++i) {
    float t      = (float(i)/steps)*tMax;
    float dt     = tMax/steps;

    vec3  newPos = pos + t*rayDir;

    vec3  rayleighScattering;
    vec3  extinction;
    float mieScattering;
    scatteringValues(newPos, rayleighScattering, mieScattering, extinction);

    vec3 sampleTransmittance = exp(-dt*extinction);

    vec3 sunTransmittance = textureLUT(tLUT, newPos, sunDir);
    vec3 psiMS            = textureLUT(mLUT, newPos, sunDir);

    vec3 rayleighInScattering = rayleighScattering*(rayleighPhaseValue*sunTransmittance + psiMS);
    vec3 mieInScattering      = mieScattering*(miePhaseValue*sunTransmittance + psiMS);
    vec3 inScattering         = (rayleighInScattering + mieInScattering);

    // Integrated scattering within path segment.
    vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;

    lum += scatteringIntegral*transmittance;

    transmittance *= sampleTransmittance;
    }

  return lum;
  }

vec3 sky(vec2 inPos) {
  const vec3 viewPos = vec3(0.0, RPlanet + push.plPosY, 0.0);
  // TODO: optimize
  vec3  pos1   = inverse(vec3(inPos,1));
  vec3  pos0   = inverse(vec3(inPos,0));
  float tMax   = length(pos1-pos0);
  vec3  rayDir = (pos1-pos0)/tMax;

  vec3 sun = raymarchScattering(viewPos, rayDir, push.sunDir, tMax);
  return sun;
  }

void main() {
  const ivec3 dstSz = imageSize(fogLut);
  const ivec3 dstUV = ivec3(gl_GlobalInvocationID.xy,0);
  if(dstUV.x>=dstSz.x || dstUV.x>=dstSz.x)
    return;

  vec4 ret = vec4(0);
  imageStore(fogLut, dstUV, ret);
  }
