#version 450

#define ANY_HIT 1
//#define UNIFORM_TRAVERSE 1
//#define SHARED_STACK 1
#define DEBUG 1

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_samplerless_texture_functions : enable
#extension GL_EXT_control_flow_attributes : enable

#if defined(UNIFORM_TRAVERSE)
#  extension GL_KHR_shader_subgroup_vote : enable
#  extension GL_KHR_shader_subgroup_arithmetic : enable
#endif

#include "scene.glsl"
#include "common.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

layout(push_constant, std430) uniform UboPush {
  vec3  originLwc;
  } push;
layout(binding = 0, rgba8)  uniform  image2D    outImage;
//layout(binding = 0, r32ui)  uniform  uimage2D   outImage;
layout(binding = 1, std140) uniform  UboScene   { SceneDesc scene; };
layout(binding = 2)         uniform  texture2D  gbufDiffuse;
layout(binding = 3)         uniform  utexture2D gbufNormal;
layout(binding = 4)         uniform  texture2D  depth;
layout(binding = 5, std430) readonly buffer BVH { uvec4 nodeData[];  };

const float TMax = 1e30f;

// debug
uint numLoop = 0;
uint numTri  = 0;
uint numBox  = 0;

struct BVH8node {
  uvec4 data0;
  uvec4 data1;
  uvec4 data2;
  uvec4 data3;
  uvec4 data4;
  };

struct Ray {
  vec3 origin;
  vec3 dir;
  vec3 invDir;
  uint octInv4;
  };

// utils
uint byteExtract(uint x, uint i) {
  return bitfieldExtract(x, int(i)*8, 8);
  }

uint sign_extend_s8x4(uint x) {
  return ((x >> 7) & 0x01010101) * 0xff;
  }

uint dirToOctInv4(in vec3 d) {
  return (d.x < 0.0f ? 0 : 0x04040404) |
         (d.y < 0.0f ? 0 : 0x02020202) |
         (d.z < 0.0f ? 0 : 0x01010101);
  }

BVH8node nodeLoad(int at) {
  BVH8node node;
  node.data0 = nodeData[at+0];
  node.data1 = nodeData[at+1];
  node.data2 = nodeData[at+2];
  node.data3 = nodeData[at+3];
  node.data4 = nodeData[at+4];
  return node;
  }

//
vec3 rayTriangleTest(const Ray ray, const vec3 v0, const vec3 e1, const vec3 e2) {
  const vec3  s1    = cross(ray.dir, e2);
  const float denom = dot(s1, e1);
  ++numTri;

  if(denom >= 0.0)
    return vec3(TMax);

  const float invDemom = 1.0 / denom;
  const vec3  d        = ray.origin - v0;
  const vec3  s2       = cross(d, e1);

  const float u = dot(d,       s1) * invDemom;
  const float v = dot(ray.dir, s2) * invDemom;

  if(( u < 0.0f ) || ( u > 1.0f ) || ( v < 0.0f ) || ( u + v > 1.0f )) {
    return vec3(TMax);
    }

  float t0 = dot(e2, s2) * invDemom;
  return vec3(t0, u, v);
  }

vec3 bvh8PrimIntersect(const Ray ray, const float tMax, int at) {
  const vec3 a = uintBitsToFloat(nodeData[at+0].xyz);
  const vec3 b = uintBitsToFloat(nodeData[at+1].xyz);
  const vec3 c = uintBitsToFloat(nodeData[at+2].xyz);
  return rayTriangleTest(ray, a, b-a, c-a);
  }

uint bvh8Intersect(const Ray ray, const float tMax, const BVH8node node) {
  const vec3  p = uintBitsToFloat(node.data0.xyz);
  const uvec3 e = uvec3(byteExtract(node.data0.w, 0), byteExtract(node.data0.w, 1), byteExtract(node.data0.w, 2));

  vec3 adjInvDir = uintBitsToFloat(e << 23u) * ray.invDir;
  vec3 adjOrigin = (p - ray.origin) * ray.invDir;

#if 0
  if(rayBoxTest(adjust_ray_origin, adjInvDir, vec3(0), vec3(255.0), tMax)!=tMax)
    return 0xFF;
  return 0;
#endif

  uint hit_mask = 0;

  [[unroll]]
  for(int i=0; i<2; ++i) {
    // meta
    uint meta4       = (i == 0 ? node.data1.z : node.data1.w);
    uint is_inner4   = (meta4 & (meta4 << 1)) & 0x10101010;
    uint inner_mask4 = sign_extend_s8x4(is_inner4 << 3);
    uint bit_index4  = (meta4 ^ (ray.octInv4 & inner_mask4)) & 0x1F1F1F1F;
    uint child_bits4 = (meta4 >> 5) & 0x07070707;

    // near far
    uint q_lo_x = (i == 0 ? node.data2.x : node.data2.y);
    uint q_hi_x = (i == 0 ? node.data2.z : node.data2.w);
    uint q_lo_y = (i == 0 ? node.data3.x : node.data3.y);
    uint q_hi_y = (i == 0 ? node.data3.z : node.data3.w);
    uint q_lo_z = (i == 0 ? node.data4.x : node.data4.y);
    uint q_hi_z = (i == 0 ? node.data4.z : node.data4.w);

    uint x_min = ray.dir.x < 0.0f ? q_hi_x : q_lo_x;
    uint x_max = ray.dir.x < 0.0f ? q_lo_x : q_hi_x;

    uint y_min = ray.dir.y < 0.0f ? q_hi_y : q_lo_y;
    uint y_max = ray.dir.y < 0.0f ? q_lo_y : q_hi_y;

    uint z_min = ray.dir.z < 0.0f ? q_hi_z : q_lo_z;
    uint z_max = ray.dir.z < 0.0f ? q_lo_z : q_hi_z;

    [[unroll]]
    for(int j = 0; j < 4; ++j) {
      ++numBox;
      vec3 tmin3 = vec3(float(byteExtract(x_min, j)), float(byteExtract(y_min, j)), float(byteExtract(z_min, j)));
      vec3 tmax3 = vec3(float(byteExtract(x_max, j)), float(byteExtract(y_max, j)), float(byteExtract(z_max, j)));

      //tmin3 = tmin3 * adjInvDir + adjOrigin;
      //tmax3 = tmax3 * adjInvDir + adjOrigin;

      tmin3 = fma(tmin3, adjInvDir, adjOrigin);
      tmax3 = fma(tmax3, adjInvDir, adjOrigin);

      float tNear = max(tmin3.x, max(tmin3.y, tmin3.z));
      float tFar  = min(tmax3.x, min(tmax3.y, tmax3.z));

      if(tNear <= tFar && 0<=tFar && tNear<tMax) {
        uint child_bits = byteExtract(child_bits4, j);
        uint bit_index  = byteExtract(bit_index4,  j);
        hit_mask |= child_bits << bit_index;
        }
      }
    }

#if defined(UNIFORM_TRAVERSE)
  hit_mask = subgroupOr(hit_mask);
#endif
  return hit_mask;
  }

// stack
int   stack_size = 0;
uvec2 stack[32];

void pushStack(uvec2 v) {
  stack[stack_size] = v;
  stack_size++;
  }

uvec2 popStack() {
  return stack[--stack_size];
  }

//
vec4 traverseCWBVH8(const Ray ray, const float tMax) {
  vec3 hit = vec3(tMax,0,0);

  uvec2 nodeGroup = uvec2(0, 0x80000000);
  while((stack_size > 0 || nodeGroup.y != 0)) {
    ++numLoop;

    uvec2 primGroup;
    if((nodeGroup.y & 0xff000000) != 0) {
      uint hits_imask  = nodeGroup.y;
      int  childIndex  = findMSB(hits_imask);

      nodeGroup.y &= ~(1u << (childIndex));
      if((nodeGroup.y & 0xff000000) != 0)
        pushStack(nodeGroup);

      uint  slotIndex     = (childIndex - 24) ^ (ray.octInv4 & 0xff);
      uint  relativeIndex = bitCount(hits_imask & ~(0xffffffffu << slotIndex));

      const uint     nodeId  = nodeGroup.x + relativeIndex*5u;
      const BVH8node node    = nodeLoad(int(nodeId));
      const uint     hitmask = bvh8Intersect(ray, hit.x, node);
      const uint     imask   = byteExtract(node.data0.w, 3);

      nodeGroup.x = node.data1.x;
      primGroup.x = node.data1.y;

      nodeGroup.y = (hitmask & 0xff000000) | imask;
      primGroup.y = (hitmask & 0x00ffffff);
      } else {
      primGroup = nodeGroup;
      nodeGroup = uvec2(0);
      }

    while(primGroup.y != 0) {
      int triangleInd = findMSB(primGroup.y);
      primGroup.y &= ~(1 << triangleInd);

      const uint primId = primGroup.x + triangleInd;
      const vec3 pHit   = bvh8PrimIntersect(ray, hit.x, int(primId));
      if(pHit.x<hit.x) {
        hit = pHit;
#if defined(ANY_HIT)
        return vec4(hit.x, hit.yz, 1.0-hit.y-hit.z);
#endif
        }
      }

    if((nodeGroup.y & 0xff000000) == 0) {
      if(stack_size == 0)
        break;
      nodeGroup = popStack();
      }

    //break;
    }

  //return vec4(numLoop/255.0);
  //return vec4(numTri /255.0);
  //return vec4(numBox /255.0);
  return vec4(hit.x, hit.yz, 1.0-hit.y-hit.z);
  }

vec4 rayTest(vec3 pos, vec3 rayDirection, float tMin, float tMax) {
  Ray r;
  r.origin  = pos;
  r.dir     = rayDirection;
  r.invDir  = 1.0/r.dir;
  r.octInv4 = dirToOctInv4(r.dir);

  // trace
  vec4 hit = traverseCWBVH8(r, tMax);
  return hit;
  }

vec4 worldPosLwc(vec2 frag, float depth) {
  const vec2 fragCoord = (frag.xy*scene.screenResInv)*2.0 - vec2(1.0);
  const vec4 scr       = vec4(fragCoord.x, fragCoord.y, depth, 1.0);
  return scene.viewProjectLwcInv * scr;
  }

vec4 shadowMain(ivec2 fragCoord) {
  if(any(greaterThanEqual(gl_GlobalInvocationID.xy, imageSize(outImage))))
    return vec4(0);

  const float d      = texelFetch(depth, fragCoord, 0).r;
  const vec3  normal = normalFetch(gbufNormal, fragCoord);
  if(d==1.0)
    return vec4(0);

  if(dot(normal, scene.sunDir)<=0)
    return vec4(0);

  const float NormalBias = 0.0015;
  const vec4  wpos4      = worldPosLwc(vec2(fragCoord+0.5), d) + vec4(normal*NormalBias, 0);
  const vec3  wpos       = wpos4.xyz/wpos4.w + push.originLwc;

  const float tMin = 5;
  const float tMax = TMax; //5000*100;
  const vec4  hit  = rayTest(wpos, scene.sunDir, tMin, tMax);
  if(hit.x!=tMax)
    return vec4(hit.yzw, 1);
  return vec4(0);
  }

void main() {
#if 1
  vec4 outColor = shadowMain(ivec2(gl_GlobalInvocationID.xy));
  if(all(lessThan(gl_GlobalInvocationID.xy, imageSize(outImage)))) {
    imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), outColor.xyzz);
    }
#else
  const mat4 inv = scene.viewProjectInv;
  const vec2 uv  = vec2(gl_GlobalInvocationID.xy+0.5)/vec2(imageSize(outImage));
  const vec4 s   = inv*vec4(uv * 2.0 - 1.0, 0.0, 1);
  const vec4 e   = inv*vec4(uv * 2.0 - 1.0, 1.0, 1);

  Ray r;
  r.origin  = s.xyz/s.w;
  r.dir     = normalize(e.xyz/e.w - r.origin);
  r.invDir  = 1.0/r.dir;
  r.octInv4 = dirToOctInv4(r.dir);

  // trace
  vec4 outColor = vec4(0);

  vec4 hit = traverseCWBVH8(r, TMax);
  if(hit.x!=TMax) {
    outColor = vec4(hit.yzw, 1);
    }

  if(all(lessThan(gl_GlobalInvocationID.xy, imageSize(outImage)))) {
    imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), outColor);
    }
#endif
  }
