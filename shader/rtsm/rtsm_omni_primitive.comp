#version 450

#extension GL_GOOGLE_include_directive    : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_samplerless_texture_functions : enable
#extension GL_EXT_control_flow_attributes : enable

#include "common.glsl"
#include "scene.glsl"
#include "rtsm/rtsm_common.glsl"

layout(local_size_x = 512) in;

const uint NumThreads = gl_WorkGroupSize.x*gl_WorkGroupSize.y*gl_WorkGroupSize.z;
const uint sizeof_Light = 1 + 4*6;

layout(push_constant, std430) uniform UboPush {
  vec3  originLwc;
  float znear;
  } push;
layout(binding = 0)         uniform  utexture2D lightTiles;
layout(binding = 1, std140) uniform  UboScene   { SceneDesc scene; };
layout(binding = 2)         uniform  utexture2D gbufNormal;
layout(binding = 3)         uniform  texture2D  depth;
layout(binding = 4, std430)          buffer Pos { uint  alloc; uint    data[]; } pos;
layout(binding = 5, std430) readonly buffer Lbo { LightSource lights[];        };
layout(binding = 6, std430) readonly buffer VId { uvec4 count; LightId data[]; } vLights;
layout(binding = 7)         uniform  utexture2D lightBins;
layout(binding = 8, rg32ui) uniform  uimage2D   primTiles;

#if defined(DEBUG_IMG)
layout(binding = 9, r32ui)  uniform  uimage2D   dbgImage;
#endif

shared uint dbgCounter;
void imageDbg(uint info) {
#if defined(DEBUG_IMG)
  imageStore(dbgImage, ivec2(gl_WorkGroupID.xy), uvec4(info));
#endif
  }

#include "rtsm/rtsm_scratch.glsl"
// #include "rtsm/rtsm_omni_bboxes.glsl"

shared uint numLights;
shared uint numPrimitives;
shared uint primitives[2048];

shared uint lightsBinPtr, primListPtr;

ivec2 fragCoord = ivec2(gl_GlobalInvocationID.xy);

//const ivec2 TileSize = ivec2(RTSM_SMALL_TILE);
const ivec2 TileSize = ivec2(RTSM_LIGHT_TILE);

uvec2 pullTileData() {
  return texelFetch(lightTiles, ivec2((gl_WorkGroupID.xy*TileSize)/RTSM_LIGHT_TILE), 0).xy;
  }

void storeBin(ivec2 at, uint ptr, uint num) {
  if(gl_LocalInvocationIndex!=0)
    return;
  if(num==0)
    ptr = NULL;
  imageStore(primTiles, at, uvec4(ptr,num,0,0));
  }

uint packPrimitiveId(uint meshlet, uint prim) {
  return (meshlet << 8) | prim;
  }

// visibility
shared uint  numPlanes;
shared uvec4 bbox[6];
shared vec3  frustum[6][4];
void rayBboxes(const uint lptr) {
  const uint laneID = gl_LocalInvocationIndex;

  numPlanes = 0;
  barrier();

  if(laneID<6) {
    const uint  face  = laneID;
    const uint  fptr  = lptr + 1 + face*4;

    uvec4 iaabb;
    iaabb.x = pos.data[fptr+0];
    iaabb.y = pos.data[fptr+1];
    iaabb.z = pos.data[fptr+2];
    iaabb.w = pos.data[fptr+3];

    if(iaabb.x>=iaabb.z || iaabb.y>=iaabb.w) {
      // degenerated bbox
      return;
      }
    const vec4 aabb = orderedUintToFloat(iaabb);
    const vec3 fa   = faceToRay(vec2(aabb.xy), face);
    const vec3 fb   = faceToRay(vec2(aabb.zy), face);
    const vec3 fc   = faceToRay(vec2(aabb.zw), face);
    const vec3 fd   = faceToRay(vec2(aabb.xw), face);

    const uint id = atomicAdd(numPlanes, 1);
    frustum[id][0] = cross(fa, fb);
    frustum[id][1] = cross(fb, fc);
    frustum[id][2] = cross(fc, fd);
    frustum[id][3] = cross(fd, fa);
    }
  }

bool isPrimitiveVisible(vec3 a, vec3 b, vec3 c, uint face) {
  const vec3 p0 = frustum[face][0];
  const vec3 p1 = frustum[face][1];
  const vec3 p2 = frustum[face][2];
  const vec3 p3 = frustum[face][3];

  if(dot(a, p0)<0 && dot(b, p0)<0 && dot(c, p0)<0)
    return false;
  if(dot(a, p1)<0 && dot(b, p1)<0 && dot(c, p1)<0)
    return false;
  if(dot(a, p2)<0 && dot(b, p2)<0 && dot(c, p2)<0)
    return false;
  if(dot(a, p3)<0 && dot(b, p3)<0 && dot(c, p3)<0)
    return false;
  return true;
  }

bool isPrimitiveVisible(vec3 a, vec3 b, vec3 c) {
  const uint num = numPlanes;
  for(uint face=0; face<num; ++face) {
    if(isPrimitiveVisible(a, b, c, face))
      return true;
    }
  return false;
  }

bool isPrimitiveVisible(const uint ptr, const uint primId, const LightSource src) {
  uint ptrM = ptr;

  ptrM += MeshletHeaderSize;
  const uvec3 tri = pullPrimitive(ptrM, primId);

  ptrM += MaxPrim;
  const vec3  a   = pullVertex(ptrM, tri.x) - src.pos;
  const vec3  b   = pullVertex(ptrM, tri.y) - src.pos;
  const vec3  c   = pullVertex(ptrM, tri.z) - src.pos;

  /*
  //TODO: tMax culling
  vec4 plane;
  // plane.xyz = normalize(cross(b - a, c - a));
  plane.xyz = cross(b - a, c - a);
  plane.w   = dot(plane.xyz, a);

  const float dist = -plane.w;
  // if(dist<0)
  //   return false;
  if(dist*dist>(src.range*src.range)*dot(plane.xyz,plane.xyz))
    return false;
  */

  if(!isPrimitiveVisible(a, b, c))
    return false;
  return true;
  }

void processPrimitives(const uint tilePtr, const uint inPrimitives, const LightSource src) {
  const uint laneID = gl_LocalInvocationIndex;

  numPrimitives = 0;
  barrier();

  for(uint i=laneID; i<inPrimitives; i+=NumThreads) {
    const uint  pkg    = pos.data[tilePtr + i];
    const uint  ptr    = (pkg >> 8);
    const uint  primId = pkg & 0xFF;

    if(!isPrimitiveVisible(ptr, primId, src))
      continue;

    atomicAdd(dbgCounter, 1);
    const uint id = atomicAdd(numPrimitives, 1);
    if(id<primitives.length()) {
      primitives[id] = packPrimitiveId(ptr, primId);
      }
    }
  }

void processLight(const LightId lId, const uint inPrimitives) {
  const uint laneID = gl_LocalInvocationIndex;

  const LightSource src      = lights[lId.id];
  const uint        tilePtr  = lId.ptr;

  processPrimitives(tilePtr, inPrimitives, src);
  barrier();

  if(laneID==0) {
    if(numPrimitives<primitives.length()) {
      primListPtr   = allocScratch(numPrimitives);
      } else {
      primListPtr   = NULL;
      numPrimitives = BIN_BAD_BIT;
      }

    const uint idx = atomicAdd(numLights, 1);
    pos.data[lightsBinPtr + idx*4 + 0] = lId.id;
    pos.data[lightsBinPtr + idx*4 + 1] = primListPtr;
    pos.data[lightsBinPtr + idx*4 + 2] = numPrimitives;
    }
  barrier();

  if(primListPtr==NULL)
    return;
  for(uint i=laneID; i<numPrimitives; i+=NumThreads)
    pos.data[primListPtr + i] = primitives[i];
  }

void main() {
  const uint  laneID  = gl_LocalInvocationIndex;
  const uvec2 tile    = pullTileData();
  const uint  lptr    = tile.x;
  const uint  nLights = tile.y;

  if(nLights==0) {
    storeBin(ivec2(gl_WorkGroupID.xy), NULL, 0);
    imageDbg(0);
    return;
    }

  if(laneID==0)
    lightsBinPtr = allocScratch(nLights*4);

  dbgCounter = 0;
  numLights  = 0;
  numPrimitives = 0; //debug
  barrier();

  if(lightsBinPtr==NULL) {
    storeBin(ivec2(gl_WorkGroupID.xy), NULL, BIN_BAD_BIT);
    imageDbg(0);
    return;
    }

  for(uint i=0; i<nLights; ++i) {
    const uint id           = pos.data[lptr + i*sizeof_Light];
    const uint inPrimitives = texelFetch(lightBins, ivec2(id,0), 0).x;

    rayBboxes(lptr + i*sizeof_Light);
    barrier();

    if(numPlanes>0)
      processLight(vLights.data[id], inPrimitives);
    barrier();
    }

  storeBin(ivec2(gl_WorkGroupID.xy), lightsBinPtr, numLights);
  imageDbg(dbgCounter);
  //imageDbg(numLights);
  }
