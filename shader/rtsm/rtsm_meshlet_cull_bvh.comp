#version 450

#extension GL_GOOGLE_include_directive : enable

#include "rtsm/rtsm_common.glsl"
#include "scene.glsl"
#include "common.glsl"

layout(local_size_x = 32, local_size_y = 16) in;

const uint NumThreads = gl_WorkGroupSize.x*gl_WorkGroupSize.y*gl_WorkGroupSize.z;

layout(binding = 0)         uniform texture2D   outputImage;
layout(binding = 1, std140) uniform UboScene    { SceneDesc scene;   };
layout(binding = 2)         uniform texture2D   depth;
layout(binding = 3, std430)         buffer Pos  { uint  alloc; uint data[];  } pos;

layout(binding = 5, rg32ui) uniform writeonly uimage2D tileBins;

layout(binding = 9, r32ui)  uniform uimage2D           dbgImage;

void imageDbg(ivec2 at, uint info) {
//#if defined(DEBUG_IMG)
  imageStore(dbgImage, at, uvec4(info));
//#endif
  }

#include "rtsm/rtsm_scratch.glsl"

// tiles: 128 -> 32, 5'576 bytes
#include "rtsm/rtsm_tile_bboxes.glsl"

shared uint  numMeshlets[16];
shared uint  meshListPtr[16];

shared uint  meshletsId [NumThreads*2];

void traceMeshlets(const uint tilePtr, const uint visCount, const bool count) {
  const uint laneID = gl_LocalInvocationIndex;

  for(uint i=laneID; i<visCount; i+=NumThreads) {
    const uint  ptr      = pos.data[tilePtr + i];
    const vec4  aabb     = pullMeshAabb(ptr);
    const float depthMax = pullMeshDepthMax(ptr);
    if(!isAabbVisible(aabb, depthMax, 0))
      continue;

    for(int r=0; r<16; ++r) {
      if(!isAabbVisible(aabb, depthMax, r+1))
        continue;

      const uint id = atomicAdd(numMeshlets[r], 1);
      if(!count && meshListPtr[r]!=NULL)
        pos.data[meshListPtr[r] + id] = ptr;
      }
    }
  }

void alloc() {
  const uint laneID = gl_LocalInvocationIndex;

  if(laneID<numMeshlets.length()) {
    const uint size = numMeshlets[laneID];
    meshListPtr[laneID] = allocScratch(size);
    numMeshlets[laneID] = 0;
    }
  }

void main() {
  const uint laneID = gl_LocalInvocationIndex;

  tileBboxes(ivec2(gl_WorkGroupID.xy), RTSM_LARGE_TILE);
  if(laneID<numMeshlets.length())
    numMeshlets[laneID] = 0;
  barrier();

  if(numSlices[0]==0) {
    for(int i=0; i<16; ++i) {
      ivec2 tileId  = ivec2(gl_WorkGroupID.xy)*4 + ivec2(i%4, i/4);
      imageStore(tileBins, tileId, uvec4(0));
      }
    return;
    }

  traceMeshlets(1, pos.data[0], true);
  barrier();

  alloc();
  barrier();

  traceMeshlets(1, pos.data[0], false);
  barrier();

  for(int i=0; i<16; ++i) {
    ivec2 tileId  = ivec2(gl_WorkGroupID.xy)*4 + ivec2(i%4, i/4);
    imageStore(tileBins, tileId, uvec4(meshListPtr[i], numMeshlets[i], 0, 0));
    }

  // debug
  barrier();
  for(int i=0; i<16; ++i) {
    ivec2 at  = ivec2(gl_WorkGroupID.xy)*4 + ivec2(i%4, i/4);
    imageDbg(at, numMeshlets[i]);
    }
  }
