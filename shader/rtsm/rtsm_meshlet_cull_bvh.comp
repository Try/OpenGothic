#version 450

#extension GL_GOOGLE_include_directive : enable

#include "rtsm/rtsm_common.glsl"
#include "scene.glsl"
#include "common.glsl"

layout(local_size_x = 32, local_size_y = 16) in;

const uint NumThreads = gl_WorkGroupSize.x*gl_WorkGroupSize.y*gl_WorkGroupSize.z;

layout(binding = 0)         uniform texture2D   outputImage;
layout(binding = 1, std140) uniform UboScene    { SceneDesc scene;   };
layout(binding = 2)         uniform texture2D   depth;
layout(binding = 3, std430)         buffer Pos  { uint  alloc; uint data[];  } pos;

layout(binding = 5, rg32ui) uniform writeonly uimage2D tileBins;

layout(binding = 9, r32ui)  uniform uimage2D           dbgImage;

void imageDbg(ivec2 at, uint info) {
//#if defined(DEBUG_IMG)
  imageStore(dbgImage, at, uvec4(info));
//#endif
  }

#include "rtsm/rtsm_scratch.glsl"

// tiles: 128 -> 32, 5'576 bytes
#include "rtsm/rtsm_tile_bboxes.glsl"

shared uint  numMeshlets;
shared uint  meshListPtr;

shared uint  meshletsId[2048];

void traceMeshlets(const uint tilePtr, const uint visCount, const int boxId, const bool count) {
  const uint laneID = gl_LocalInvocationIndex;

  for(uint i=laneID; i<visCount; i+=NumThreads) {
    const uint  ptr      = pos.data[tilePtr + i];
    const vec4  aabb     = pullMeshAabb(ptr);
    const float depthMax = pullMeshDepthMax(ptr);

    if(!isAabbVisible(aabb, depthMax, boxId))
      continue;

    const uint id = atomicAdd(numMeshlets, 1);
    if(count && id<meshletsId.length())
      meshletsId[id] = ptr;
    else if(!count)
      pos.data[meshListPtr + id] = ptr;
    }
  }

void processTiling(const uint tilePtr, const uint visCount, const int boxId) {
  const uint laneID = gl_LocalInvocationIndex;

  numMeshlets = 0;
  barrier();

  traceMeshlets(tilePtr, visCount, boxId, true);
  barrier();

  const bool secondPass = (numMeshlets > meshletsId.length());
  if(laneID==0)
    meshListPtr = allocScratch(numMeshlets);
  barrier();

  if(secondPass) {
    numMeshlets = 0;
    barrier();

    traceMeshlets(tilePtr, visCount, boxId, false);
    return;
    }

  for(uint i=laneID; i<numMeshlets; i+=NumThreads) {
    pos.data[meshListPtr + i] = meshletsId[i];
    }
  }

void main() {
  const uint laneID = gl_LocalInvocationIndex;

  tileBboxes(ivec2(gl_WorkGroupID.xy), RTSM_LARGE_TILE);
  barrier();

  if(numSlices[0]==0) {
    for(int i=0; i<16; ++i) {
      ivec2 tileId  = ivec2(gl_WorkGroupID.xy)*4 + ivec2(i%4, i/4);
      imageStore(tileBins, tileId, uvec4(0));
      imageDbg(tileId, 0); // debug
      }
    return;
    }

  processTiling(1, pos.data[0], 0);
  memoryBarrierBuffer();
  barrier();

  const uint numMeshletsGlob = numMeshlets;
  const uint meshListPtrGlob = meshListPtr;
  for(int i=0; i<16; ++i) {
    barrier();

    processTiling(meshListPtrGlob, numMeshletsGlob, 1+i);

    ivec2 tileId  = ivec2(gl_WorkGroupID.xy)*4 + ivec2(i%4, i/4);
    imageStore(tileBins, tileId, uvec4(meshListPtr, numMeshlets, 0, 0));
    imageDbg(tileId, numMeshlets); // debug
    }
  }
