#version 450

#extension GL_GOOGLE_include_directive : enable

#include "rtsm/rtsm_common.glsl"
#include "scene.glsl"
#include "common.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

const uint  NumThreads = gl_WorkGroupSize.x*gl_WorkGroupSize.y*gl_WorkGroupSize.z;
      float FLT_MAX    = uintBitsToFloat(2139095039u);
const float TMax       = 1e30f;
const uint  MaxLoop    = 255;

const uint  BVH_NullNode = 0x00000000;
const uint  BVH_BoxNode  = 0x10000000;
const uint  BVH_MeshNode = 0x20000000;

struct BVHNode {
  vec4 self;
  vec4 aabb[64];
  uint ptr [64];
  };

layout(binding = 0)         uniform texture2D   outputImage;
layout(binding = 1, std140) uniform UboScene    { SceneDesc scene;       };
layout(binding = 2)         uniform texture2D   depth;
layout(binding = 3, std430) coherent buffer Pos  { uint alloc; uint data[]; } pos;
layout(binding = 4, std430) readonly buffer Bvh  { BVHNode node[1+64];      } bvh;

//layout(binding = 5, rg32ui) uniform uimage2D    tileBins;

layout(binding = 9, r32ui)  uniform uimage2D    dbgImage;

void imageDbg(ivec2 at, uint info) {
#if defined(DEBUG_IMG)
  imageStore(dbgImage, at, uvec4(info));
#endif
  }

#include "rtsm/rtsm_scratch.glsl"

shared uint numBox;
shared uint numMeshlets;

// ray related
vec3 rayOrigin(ivec2 frag, float depth) {
  const vec2 fragCoord = ((frag.xy+0.5)*scene.screenResInv)*2.0 - vec2(1.0);
  const vec4 scr       = vec4(fragCoord.x, fragCoord.y, depth, 1.0);

  const vec4 shPos = scene.viewProject2VirtualShadow * scr;
  return shPos.xyz/shPos.w;
  }

uint bvhGetNodeType(uint ptr) {
  return ptr & 0xF0000000;
  }

//
shared uint  stackSize;
shared uint  stack[128];
uint popStack(){
  const uint nodeId = stack[stackSize-1];
  barrier();

  if(gl_LocalInvocationIndex==0)
    stackSize--;
  return nodeId;
  }

shared uvec4 rayTileBbox;
shared uint  rayDepthMin;
void processBoxNode(const vec3 ray, bool actRay, const uint nodeId) {
  const uint laneID = gl_LocalInvocationIndex;
  const uint nptr   = nodeId & 0x0FFFFFFF;
  const vec4 aabb   = bvh.node[nptr].self;

#if 0
  rayTileBbox = uvec4(0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
  rayDepthMin = 0xFFFFFFFF;
  barrier();

  if(actRay && bboxIncludes(aabb, ray.xy)) {
    atomicMin(rayTileBbox.x, floatToOrderedUint(ray.x));
    atomicMin(rayTileBbox.y, floatToOrderedUint(ray.y));
    atomicMax(rayTileBbox.z, floatToOrderedUint(ray.x));
    atomicMax(rayTileBbox.w, floatToOrderedUint(ray.y));

    atomicMin(rayDepthMin,   floatToOrderedUint(ray.z));
    }
  barrier();

  if(rayTileBbox.x==0xFFFFFFFF)
    return; // empty packet

  if(laneID==0) {
    vec4  rbb  = orderedUintToFloat(rayTileBbox);
    float rayD = orderedUintToFloat(rayDepthMin);
    rayTileBbox = floatBitsToUint(rbb);
    rayDepthMin = floatBitsToUint(rayD);
    }
  barrier();
#endif

  if(laneID>=64)
    return;

  const vec4 leaf = bvh.node[nptr].aabb[laneID];
  const uint ptr  = bvh.node[nptr].ptr [laneID];
  if(ptr==0)
    return;

  const vec4  rbb   = uintBitsToFloat(rayTileBbox);
  const float rdMin = uintBitsToFloat(rayDepthMin);

  //if(leaf.bbmax.y<rdMin)
  //  return;
  if(!bboxIntersect(rbb, vec4(leaf)))
    return;

  atomicAdd(numBox, 1);
  const uint ins = atomicAdd(stackSize, 1);
  stack[ins] = ptr;
  }

vec3 trace(const vec3 ray, bool actRay) {
  stackSize = 1;
  stack[0]  = uint(0 | BVH_BoxNode);
  barrier();

  vec3 ret = vec3(TMax);
  int i = 0;
  for(; i<MaxLoop; ++i) {
    if(stackSize==0)
      break;

    const uint nodeId = popStack();
    const uint type   = bvhGetNodeType(nodeId);
    barrier();

    if(type==BVH_MeshNode) {
      // processTriNode(ret, nodeId, ray, actRay);
      }
    else if(type==BVH_BoxNode) {
      processBoxNode(ray, actRay, nodeId);
      }
    barrier();
    }

  return ret;
  }

// fragment
vec3 processFragment(ivec2 fragCoord) {
  const uint  laneID = gl_LocalInvocationIndex;
  const bool  valid  = all(lessThan(fragCoord, textureSize(outputImage,0)));
  const float lamb   = valid ? texelFetch(outputImage, fragCoord, 0).x : 0;
  const bool  actRay = lamb>0;
  const float z      = actRay ? texelFetch(depth, fragCoord, 0).x : 1.0;
  const vec3  ray    = actRay ? rayOrigin(fragCoord, z)           : vec3(FLT_MAX);

#if 1
  rayTileBbox = uvec4(0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
  rayDepthMin = 0xFFFFFFFF;
  barrier();

  if(actRay) {
    atomicMin(rayTileBbox.x, floatToOrderedUint(ray.x));
    atomicMin(rayTileBbox.y, floatToOrderedUint(ray.y));
    atomicMax(rayTileBbox.z, floatToOrderedUint(ray.x));
    atomicMax(rayTileBbox.w, floatToOrderedUint(ray.y));

    atomicMin(rayDepthMin,   floatToOrderedUint(ray.z));
    }
  barrier();

  if(rayTileBbox.x==0xFFFFFFFF)
    return vec3(0); // empty packet

  if(laneID==0) {
    vec4  rbb  = orderedUintToFloat(rayTileBbox);
    float rayD = orderedUintToFloat(rayDepthMin);
    rayTileBbox = floatBitsToUint(rbb);
    rayDepthMin = floatBitsToUint(rayD);
    }
  barrier();
#endif

  return trace(ray, actRay);
  }

void main() {
  numBox      = 0;
  numMeshlets = 0;
  barrier();

  const ivec2 tile = ivec2(gl_WorkGroupID.xy);
  processFragment(ivec2(gl_GlobalInvocationID.xy));

  imageDbg(tile, numBox);
  imageDbg(tile, numMeshlets);
  }
