#version 450

#extension GL_GOOGLE_include_directive : enable

#include "rtsm/rtsm_common.glsl"
#include "scene.glsl"
#include "common.glsl"

layout(local_size_x = 32, local_size_y = 16) in;

const uint NumThreads = gl_WorkGroupSize.x*gl_WorkGroupSize.y*gl_WorkGroupSize.z;

layout(binding = 0)         uniform texture2D   outputImage;
layout(binding = 1, std140) uniform UboScene    { SceneDesc scene;   };
layout(binding = 2)         uniform  utexture2D gbufNormal;
layout(binding = 3)         uniform texture2D   depth;
layout(binding = 4, std430)         buffer Pos  { uint  alloc; uint data[];  } pos;
layout(binding = 5, rg32ui) uniform writeonly uimage2D tileBins;

layout(binding = 9, r32ui)  uniform uimage2D           dbgImage;

void imageDbg(ivec2 at, uint info) {
#if defined(DEBUG_IMG)
  imageStore(dbgImage, at, uvec4(info));
#endif
  }

#include "rtsm/rtsm_scratch.glsl"

// tiles: 128 -> 32, 5'576 bytes
#include "rtsm/rtsm_tile_bboxes.glsl"

shared uint  numMeshlets[16];
shared uint  meshListPtr[16];

shared uint  meshletsId[2048];

void storeTile(ivec2 tileId, uint ptr, uint size) {
  imageStore(tileBins, tileId, uvec4(ptr, size, 0, 0));
  imageDbg(tileId, size); // debug
  }

void traceMeshlets(const uint tilePtr, const uint visCount, const int boxId, const bool count) {
  const uint laneID = gl_LocalInvocationIndex;

  for(uint i=laneID; i<visCount; i+=NumThreads) {
    const uint  ptr      = pos.data[tilePtr + i];
    const vec4  aabb     = pullMeshAabb(ptr);
    const float depthMax = pullMeshDepthMax(ptr);

    if(!isAabbVisible(aabb, depthMax, boxId))
      continue;

    const uint id = atomicAdd(numMeshlets[0], 1);
    if(count && id<meshletsId.length())
      meshletsId[id] = ptr;
    else if(!count)
      pos.data[meshListPtr[0] + id] = ptr;
    }
  }

void traceMeshletsFine(const uint tilePtr, const uint visCount, const bool count) {
  const uint laneID = gl_LocalInvocationIndex;

  for(uint i=laneID; i<visCount; i+=NumThreads) {
    const uint  ptr      = pos.data[tilePtr + i];
    const vec4  aabb     = pullMeshAabb(ptr);
    const float depthMax = pullMeshDepthMax(ptr);

    for(int r=0; r<16; ++r) {
      if(!isAabbVisible(aabb, depthMax, r+1))
        continue;
      const uint id = atomicAdd(numMeshlets[r], 1);
      if(!count && meshListPtr[r]!=NULL)
        pos.data[meshListPtr[r] + id] = ptr;
      }
    }
  }

void processFineTiling(const uint tilePtr, const uint visCount) {
  const uint laneID = gl_LocalInvocationIndex;

  if(laneID<16)
    numMeshlets[laneID] = 0;
  barrier();

  traceMeshletsFine(tilePtr, visCount, true);
  barrier();

  if(laneID<16) {
    const uint size = numMeshlets[laneID];
    const uint ptr  = allocScratch(size);
    numMeshlets[laneID] = 0;
    meshListPtr[laneID] = ptr;

    const ivec2 tileId = ivec2(gl_WorkGroupID.xy)*4 + ivec2(laneID%4, laneID/4);
    storeTile(tileId, ptr, size);
    }
  barrier();

  traceMeshletsFine(tilePtr, visCount, false);
  }

void processTiling(const uint tilePtr, const uint visCount, const int boxId) {
  const uint laneID = gl_LocalInvocationIndex;

  numMeshlets[0] = 0;
  barrier();

  traceMeshlets(tilePtr, visCount, boxId, true);
  barrier();

  const bool secondPass = (numMeshlets[0] > meshletsId.length());
  if(laneID==0)
    meshListPtr[0] = allocScratch(numMeshlets[0]);
  barrier();

  if(secondPass) {
    numMeshlets[0] = 0;
    barrier();

    traceMeshlets(tilePtr, visCount, boxId, false);
    return;
    }

  const uint numMeshletsGlob = numMeshlets[0];
  const uint meshListPtrGlob = meshListPtr[0];
  for(uint i=laneID; i<numMeshletsGlob; i+=NumThreads) {
    pos.data[meshListPtrGlob + i] = meshletsId[i];
    }
  }

void main() {
  const uint laneID = gl_LocalInvocationIndex;

  tileBboxes(ivec2(gl_WorkGroupID.xy), RTSM_LARGE_TILE);
  barrier();

  if(numSlices[0]==0) {
    for(int i=0; i<16; ++i) {
      ivec2 tileId = ivec2(gl_WorkGroupID.xy)*4 + ivec2(i%4, i/4);
      storeTile(tileId, NULL, 0);
      }
    return;
    }

  processTiling(1, pos.data[0], 0);
  memoryBarrierBuffer();
  barrier();

  const uint numMeshletsGlob = numMeshlets[0];
  const uint meshListPtrGlob = meshListPtr[0];
  barrier();

  processFineTiling(meshListPtrGlob, numMeshletsGlob);
  }
