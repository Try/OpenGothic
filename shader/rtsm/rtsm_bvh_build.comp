#version 450

#extension GL_GOOGLE_include_directive : enable

#include "rtsm/rtsm_common.glsl"
#include "scene.glsl"
#include "common.glsl"

layout(local_size_x = 512) in;

const uint NumThreads = gl_WorkGroupSize.x*gl_WorkGroupSize.y*gl_WorkGroupSize.z;

const int BVH_BINS = 32;

struct BVHNode {
  vec4 self;
  vec4 aabb [4];
  uint count[4];
  };

layout(binding = 0, std430)          buffer Bvh { BVHNode nodes[1];  } bvh;
layout(binding = 1, std430)          buffer Ibo { uint    indices[]; } ibo;
layout(binding = 2, std430) readonly buffer Pos { uint    alloc; uint data[]; } pos;

layout(binding = 9, std430)          buffer Dbg { vec4  aabb; uint bins[BVH_BINS*4]; uvec3 bin0; vec4 l0Aabb[4]; } dbg;

#define CONST_SCRATCH 1
#include "rtsm/rtsm_scratch.glsl"

shared uvec4 unodeAabb;
shared uint  sahBins[BVH_BINS * 4];
shared uvec4 binAabb[BVH_BINS * 4];

shared uvec3 l0Bins;
shared uvec4 l0Aabb[4];

int binIdOf(vec2 cen, int axis, float base, float size) {
  int bin = 0;
  if(axis==0)
    bin = int((BVH_BINS*(cen.x-base))/size);
  else if(axis==1)
    bin = int((BVH_BINS*(cen.y-base))/size);
  return clamp(bin, 0, int(BVH_BINS-1));
  }

int binIdOf(vec2 cen, vec4 aabb) {
  const vec2 xy   = aabb.xy;
  const vec2 size = aabb.zw - xy;
  const int  axis = (size.x>=size.y) ? 0 : 1;

  int bin = 0;
  if(axis==0)
    bin = int((BVH_BINS*(cen.x-xy.x))/size.x);
  else if(axis==1)
    bin = int((BVH_BINS*(cen.y-xy.y))/size.x);

  return clamp(bin, 0, BVH_BINS-1);
  }

void bboxGlobal(const uint visPtr, const uint visCount) {
  const uint laneID = gl_LocalInvocationIndex;

  unodeAabb = uvec4(0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
  barrier();

  for(uint i=laneID; i<visCount; i+=NumThreads) {
    const uint ptr  = pos.data[visPtr + i];
    const vec4 aabb = pullMeshAabb(ptr);

    const uvec4 uaabb = floatToOrderedUint(aabb);
    atomicMin(unodeAabb.x, uaabb.x);
    atomicMin(unodeAabb.y, uaabb.y);
    atomicMax(unodeAabb.z, uaabb.z);
    atomicMax(unodeAabb.w, uaabb.w);
    }
  }

void clearBinning() {
  const uint laneID = gl_LocalInvocationIndex;

  if(laneID<sahBins.length()) {
    sahBins[laneID] = 0;
    binAabb[laneID] = uvec4(0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
    }
  }

void processBinning(const vec4 nodeAabb, const uint depth, const uint visPtr, const uint visCount) {
  const uint  laneID = gl_LocalInvocationIndex;

  const vec2  sz     = nodeAabb.zw - nodeAabb.xy;
  const int   axis   = (sz.x>=sz.y) ? 0 : 1;
  const float base   = axis==0 ? nodeAabb.x : nodeAabb.y;
  const float size   = axis==0 ? sz.x : sz.y;

  for(uint i=laneID; i<visCount; i+=NumThreads) {
    const uint ptr  = pos.data[visPtr + i];
    const vec4 aabb = pullMeshAabb(ptr);
    const vec2 cen  = (aabb.xy + aabb.zw)*0.5;

    int bin = binIdOf(cen, axis, base, size);
    if(depth>0) {
      if(bin<=l0Bins.x)
        bin = binIdOf(cen, uintBitsToFloat(l0Aabb[0])) + 0;
      else if(bin<=l0Bins.y)
        bin = binIdOf(cen, uintBitsToFloat(l0Aabb[1])) + BVH_BINS;
      else if(bin<=l0Bins.z)
        bin = binIdOf(cen, uintBitsToFloat(l0Aabb[2])) + BVH_BINS*2;
      else
        bin = binIdOf(cen, uintBitsToFloat(l0Aabb[3])) + BVH_BINS*3;
      }

    const uvec4 uaabb = floatToOrderedUint(aabb);
    atomicAdd(sahBins[bin], 1);
    atomicMin(binAabb[bin].x, uaabb.x);
    atomicMin(binAabb[bin].y, uaabb.y);
    atomicMax(binAabb[bin].z, uaabb.z);
    atomicMax(binAabb[bin].w, uaabb.w);
    }
  }

void prefixSum() {
  const uint laneID = gl_LocalInvocationIndex;

  const uint binId  = laneID/BVH_BINS;
  const uint eltId  = binId<4 ? laneID%BVH_BINS : BVH_BINS;

  for(int i=1; i<BVH_BINS; i*=2) {
    const bool act = i<=eltId && eltId < BVH_BINS;
    const uint sum = act ? sahBins[laneID] + sahBins[laneID-i] : 0;
    barrier();

    if(act) sahBins[laneID] = sum;
    barrier();
    }
  }

void processSlice(const vec4 nodeAabb, const uint depth, const uint visPtr, const uint visCount) {
  // init
  clearBinning();
  barrier();

  // binning
  processBinning(nodeAabb, depth, visPtr, visCount);
  barrier();

  // prefix sum
  prefixSum();
  }

void splitL0(const uint visPtr, const uint visCount) {
  const uint laneID = gl_LocalInvocationIndex;

  const uint split0 = visCount/4;
  const uint split1 = visCount/2;
  const uint split2 = split1 + (visCount-split1)/2;

  if(laneID<BVH_BINS) {
    if((laneID==0 || sahBins[laneID-1]<split0) && split0<=sahBins[laneID])
      l0Bins.x = laneID;
    if((laneID==0 || sahBins[laneID-1]<split1) && split1<=sahBins[laneID])
      l0Bins.y = laneID;
    if((laneID==0 || sahBins[laneID-1]<split2) && split2<=sahBins[laneID])
      l0Bins.z = laneID;
    }

  if(laneID<4)
    l0Aabb[laneID] = uvec4(0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
  barrier();

  if(laneID<sahBins.length()) {
    uint idx = 0;
    if(laneID<=l0Bins.x)
      idx = 0;
    else if(laneID<=l0Bins.y)
      idx = 1;
    else if(laneID<=l0Bins.z)
      idx = 2;
    else
      idx = 3;
    uvec4 bbox = binAabb[laneID];
    atomicMin(l0Aabb[idx].x, bbox.x);
    atomicMin(l0Aabb[idx].y, bbox.y);
    atomicMax(l0Aabb[idx].z, bbox.z);
    atomicMax(l0Aabb[idx].w, bbox.w);
    }
  barrier();

  if(laneID<4) {
    const vec4 aabb = orderedUintToFloat(l0Aabb[laneID]);
    l0Aabb[laneID] = floatBitsToUint(aabb);
    }
  }

void splitL1(const uint visPtr, const uint visCount) {
  const uint laneID = gl_LocalInvocationIndex;

  const uint split0 = visCount/4;
  const uint split1 = visCount/2;
  const uint split2 = split1 + (visCount-split1)/2;

  if(laneID<BVH_BINS) {
    if((laneID==0 || sahBins[laneID-1]<split0) && split0<=sahBins[laneID])
      l0Bins.x = laneID;
    if((laneID==0 || sahBins[laneID-1]<split1) && split1<=sahBins[laneID])
      l0Bins.y = laneID;
    if((laneID==0 || sahBins[laneID-1]<split2) && split2<=sahBins[laneID])
      l0Bins.z = laneID;
    }
  }

void processMeshlets(const uint visPtr, const uint visCount) {
  const uint laneID = gl_LocalInvocationIndex;

  bboxGlobal(visPtr, visCount);
  barrier();

  const vec4 nodeAabb = orderedUintToFloat(unodeAabb);
  processSlice(nodeAabb, 0, visPtr, visCount);
  barrier();

  // split-id
  splitL0(visPtr, visCount);
  barrier();

  processSlice(nodeAabb, 1, visPtr, visCount);
  barrier();

  // split-id
  // splitL1(visPtr, visCount);

  // debug
  if(laneID<sahBins.length() && laneID/BVH_BINS==0)
    ;//dbg.bins[laneID%BVH_BINS] = sahBins[laneID];
  if(laneID<sahBins.length())
    dbg.bins[laneID] = sahBins[laneID];
  dbg.aabb = orderedUintToFloat(unodeAabb);
  dbg.bin0 = l0Bins;
  if(laneID<4)
    dbg.l0Aabb[laneID] = uintBitsToFloat(l0Aabb[laneID]);
  }

void main() {
  processMeshlets(1, pos.data[0]);
  }
