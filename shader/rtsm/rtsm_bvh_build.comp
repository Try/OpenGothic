#version 450

#extension GL_GOOGLE_include_directive : enable

#include "rtsm/rtsm_common.glsl"
#include "scene.glsl"
#include "common.glsl"

layout(local_size_x = 512) in;

const uint NumThreads = gl_WorkGroupSize.x*gl_WorkGroupSize.y*gl_WorkGroupSize.z;

const uint  BVH_NullNode = 0x00000000;
const uint  BVH_BoxNode  = 0x10000000;
const uint  BVH_MeshNode = 0x20000000;

struct BVHNode {
  vec4  self;
  vec4  aabb[256];
  float zmax[256];
  uint  size[256];
  uint  ptr [256];
  };

layout(binding = 0, std430) buffer Bvh { BVHNode nodes[1]; } bvh;
layout(binding = 1, std430) buffer Pos { uint    alloc; uint data[]; } pos;

layout(binding = 9, r32ui)  uniform  uimage2D dbg;

#include "rtsm/rtsm_scratch.glsl"

const ivec2 SLICE_SIZE = ivec2(16);

shared uvec4 sceneBbox;
shared uint  nodeBins[SLICE_SIZE.x][SLICE_SIZE.y];
shared uint  nodePtr [SLICE_SIZE.x][SLICE_SIZE.y];
shared uvec4 nodeBbox[SLICE_SIZE.x][SLICE_SIZE.y];
shared uint  nodeZMax[SLICE_SIZE.x][SLICE_SIZE.y];

void bboxGlobal(const uint visPtr, const uint visCount) {
  const uint laneID = gl_LocalInvocationIndex;

  for(uint i=laneID; i<visCount; i+=NumThreads) {
    const uint ptr  = pos.data[visPtr + i];
    const vec4 aabb = pullMeshAabb(ptr);

    const uvec4 uaabb = floatToOrderedUint(aabb);
    atomicMin(sceneBbox.x, uaabb.x);
    atomicMin(sceneBbox.y, uaabb.y);
    atomicMax(sceneBbox.z, uaabb.z);
    atomicMax(sceneBbox.w, uaabb.w);
    }
  barrier();

  if(laneID==0) {
    const vec4 aabb = orderedUintToFloat(sceneBbox);
    sceneBbox = floatBitsToUint(aabb);
    }
  }

ivec2 binIdOf(vec2 cen, const vec4 nodeAabb) {
  vec2  norm = (cen-nodeAabb.xy)/(nodeAabb.zw-nodeAabb.xy);
  ivec2 id   = ivec2(norm*vec2(SLICE_SIZE));

  return clamp(ivec2(0), ivec2(SLICE_SIZE-1), id);
  }

void processBinning(const uint visPtr, const uint visCount) {
  const uint laneID = gl_LocalInvocationIndex;

  const vec4 gAabb = uintBitsToFloat(sceneBbox);
  for(uint i=laneID; i<visCount; i+=NumThreads) {
    const uint  ptr  = pos.data[visPtr + i];
    const vec4  aabb = pullMeshAabb(ptr);
    const float zmax = pullMeshDepthMax(ptr);
    const vec2  cen  = (aabb.xy + aabb.zw)*0.5;
    const ivec2 bin  = binIdOf(cen, gAabb);

    atomicAdd(nodeBins[bin.x][bin.y],   1);
    atomicMin(nodeBbox[bin.x][bin.y].x, floatToOrderedUint(aabb.x));
    atomicMin(nodeBbox[bin.x][bin.y].y, floatToOrderedUint(aabb.y));
    atomicMax(nodeBbox[bin.x][bin.y].z, floatToOrderedUint(aabb.z));
    atomicMax(nodeBbox[bin.x][bin.y].w, floatToOrderedUint(aabb.w));
    atomicMax(nodeZMax[bin.x][bin.y],   floatToOrderedUint(zmax));
    }
  }

void processAlloc() {
  const uint laneID = gl_LocalInvocationIndex;

  const uint SLICE_SZ = SLICE_SIZE.x*SLICE_SIZE.y;
  for(uint i=laneID; i<SLICE_SZ; i+=NumThreads) {
    const ivec2 at   = ivec2(i%SLICE_SIZE.x, i/SLICE_SIZE.x);

    const uint  size = nodeBins[at.x][at.y];
    const uvec4 aabb = nodeBbox[at.x][at.y];
    const uint  zmax = nodeZMax[at.x][at.y];

    const uint  ptr  = allocScratch(size);
    nodeBins[at.x][at.y] = 0;
    nodePtr [at.x][at.y] = ptr;

    bvh.nodes[0].aabb[at.x + at.y*16] = orderedUintToFloat(aabb);
    bvh.nodes[0].zmax[at.x + at.y*16] = orderedUintToFloat(zmax);
    bvh.nodes[0].size[at.x + at.y*16] = size;
    bvh.nodes[0].ptr [at.x + at.y*16] = (ptr | BVH_MeshNode);
    }
  }

void processStore(const uint visPtr, const uint visCount) {
  const uint laneID = gl_LocalInvocationIndex;

  const vec4 gAabb = uintBitsToFloat(sceneBbox);
  for(uint i=laneID; i<visCount; i+=NumThreads) {
    const uint  ptr  = pos.data[visPtr + i];
    const vec4  aabb = pullMeshAabb(ptr);
    const vec2  cen  = (aabb.xy + aabb.zw)*0.5;

    const ivec2 bin  = binIdOf(cen, gAabb);
    if(bin.x<0 || bin.y<0 || bin.x>=SLICE_SIZE.x || bin.y>=SLICE_SIZE.y)
      continue;

    if(nodePtr[bin.x][bin.y]==NULL)
      continue; //OOM

    const uint at = atomicAdd(nodeBins[bin.x][bin.y], 1) + nodePtr[bin.x][bin.y];
    //pos.data[at] = ptr;
    }

  if(gl_GlobalInvocationID.xy==uvec2(0))
    bvh.nodes[0].self = gAabb;
  }

void processMeshlets(const int visPtr, const uint visCount) {
  const uint laneID = gl_LocalInvocationIndex;

  if(gl_WorkGroupID.xy!=ivec2(1,1))
    ;//return;
  bboxGlobal(visPtr, visCount);
  barrier();

  processBinning(visPtr, visCount);
  }

void main() {
  const uint laneID = gl_LocalInvocationIndex;

  const uint SLICE_SZ = SLICE_SIZE.x*SLICE_SIZE.y;
  for(uint i=laneID; i<SLICE_SZ; i+=NumThreads) {
    nodeBins[i%SLICE_SIZE.x][i/SLICE_SIZE.x] = 0;
    nodeBbox[i%SLICE_SIZE.x][i/SLICE_SIZE.x] = uvec4(0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
    nodeZMax[i%SLICE_SIZE.x][i/SLICE_SIZE.x] = 0;
    }
  sceneBbox = uvec4(0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
  barrier();

  processMeshlets(1, pos.data[0]);
  barrier();

  processAlloc();
  barrier();

  processStore(1, pos.data[0]);
  //barrier();

  for(uint i=laneID; i<SLICE_SZ; i+=NumThreads) {
    const uint v = nodeBins[i%SLICE_SIZE.x][i/SLICE_SIZE.x];
    imageStore(dbg, ivec2(i%SLICE_SIZE.x, i/SLICE_SIZE.x), uvec4(v));
    }
  }
