#version 450

#extension GL_GOOGLE_include_directive : enable

#include "rtsm/rtsm_common.glsl"
#include "scene.glsl"
#include "common.glsl"

layout(local_size_x = 512) in;

const uint NumThreads = gl_WorkGroupSize.x*gl_WorkGroupSize.y*gl_WorkGroupSize.z;

const uint  BVH_NullNode = 0x00000000;
const uint  BVH_BoxNode  = 0x10000000;
const uint  BVH_MeshNode = 0x20000000;

struct BVHNode {
  vec4 self;
  vec4 aabb[64];
  uint ptr [64];
  };

layout(binding = 0, std430) buffer Bvh { BVHNode nodes[1+64]; } bvh;
layout(binding = 1, std430) buffer Pos { uint    alloc; uint data[]; } pos;

layout(binding = 9, r32ui)  uniform  uimage2D dbg;

#include "rtsm/rtsm_scratch.glsl"

const ivec2 SLICE_SIZE = ivec2(16);

shared uvec4 sceneBbox;
shared uint  nodeBins[SLICE_SIZE.x][SLICE_SIZE.y];
shared uint  nodePtr [SLICE_SIZE.x][SLICE_SIZE.y];
shared uvec4 nodeBbox[SLICE_SIZE.x][SLICE_SIZE.y];

void bboxGlobal(const uint visPtr, const uint visCount) {
  const uint laneID = gl_LocalInvocationIndex;

  for(uint i=laneID; i<visCount; i+=NumThreads) {
    const uint ptr  = pos.data[visPtr + i];
    const vec4 aabb = pullMeshAabb(ptr);

    const uvec4 uaabb = floatToOrderedUint(aabb);
    atomicMin(sceneBbox.x, uaabb.x);
    atomicMin(sceneBbox.y, uaabb.y);
    atomicMax(sceneBbox.z, uaabb.z);
    atomicMax(sceneBbox.w, uaabb.w);
    }
  barrier();

  if(laneID==0) {
    const vec4 aabb = orderedUintToFloat(sceneBbox);
    sceneBbox = floatBitsToUint(aabb);
    }
  }

ivec2 binIdOf(vec2 cen, const vec4 nodeAabb) {
  vec2  norm = (cen-nodeAabb.xy)/(nodeAabb.zw-nodeAabb.xy);
  ivec2 id   = ivec2(norm*vec2(64));
  id = min(id, ivec2(64-1));

  return id - ivec2(gl_WorkGroupID.xy)*SLICE_SIZE;
  }

void processBinning(const uint visPtr, const uint visCount) {
  const uint laneID = gl_LocalInvocationIndex;

  const vec4 gAabb = uintBitsToFloat(sceneBbox);
  for(uint i=laneID; i<visCount; i+=NumThreads) {
    const uint  ptr  = pos.data[visPtr + i];
    const vec4  aabb = pullMeshAabb(ptr);
    const vec2  cen  = (aabb.xy + aabb.zw)*0.5;

    const ivec2 bin  = binIdOf(cen, gAabb);
    if(bin.x<0 || bin.y<0 || bin.x>=SLICE_SIZE.x || bin.y>=SLICE_SIZE.y)
      continue;

    atomicAdd(nodeBins[bin.x][bin.y],   1);
    atomicMin(nodeBbox[bin.x][bin.y].x, floatToOrderedUint(aabb.x));
    atomicMin(nodeBbox[bin.x][bin.y].y, floatToOrderedUint(aabb.y));
    atomicMax(nodeBbox[bin.x][bin.y].z, floatToOrderedUint(aabb.z));
    atomicMax(nodeBbox[bin.x][bin.y].w, floatToOrderedUint(aabb.w));
    }
  }

void processStore(const uint visPtr, const uint visCount) {
  const uint laneID = gl_LocalInvocationIndex;

  const vec4 gAabb = uintBitsToFloat(sceneBbox);
  for(uint i=laneID; i<visCount; i+=NumThreads) {
    const uint  ptr  = pos.data[visPtr + i];
    const vec4  aabb = pullMeshAabb(ptr);
    const vec2  cen  = (aabb.xy + aabb.zw)*0.5;

    const ivec2 bin  = binIdOf(cen, gAabb);
    if(bin.x<0 || bin.y<0 || bin.x>=SLICE_SIZE.x || bin.y>=SLICE_SIZE.y)
      continue;

    if(nodePtr[bin.x][bin.y]==NULL)
      continue; //OOM

    const uint at = atomicAdd(nodeBins[bin.x][bin.y], 1) + nodePtr[bin.x][bin.y];
    pos.data[at] = ptr;
    }
  }

void processMeshlets(const int visPtr, const uint visCount) {
  const uint laneID = gl_LocalInvocationIndex;

  if(gl_WorkGroupID.xy!=ivec2(1,1))
    ;//return;
  bboxGlobal(visPtr, visCount);
  barrier();

  processBinning(visPtr, visCount);
  barrier();

  const uint SLICE_SZ = SLICE_SIZE.x*SLICE_SIZE.y;
  for(uint i=laneID; i<SLICE_SZ; i+=NumThreads) {
    ivec2 at = ivec2(i%SLICE_SIZE.x, i/SLICE_SIZE.x);
    const uint  size = nodeBins[i%SLICE_SIZE.x][i/SLICE_SIZE.x];
    const uvec4 aabb = nodeBbox[at.x][at.y];

    at += ivec2(gl_WorkGroupID.xy)*SLICE_SIZE;

    const uint  ptr = allocScratch(size);
    const ivec2 l0  = at/8;
    const ivec2 l1  = at%8;
    bvh.nodes[1+(l0.x + l0.y*8)].aabb[l1.x + l1.y*8] = orderedUintToFloat(aabb);
    bvh.nodes[1+(l0.x + l0.y*8)].ptr [l1.x + l1.y*8] = ptr;

    nodeBins[i%SLICE_SIZE.x][i/SLICE_SIZE.x] = 0;
    nodePtr [i%SLICE_SIZE.x][i/SLICE_SIZE.x] = ptr;
    }
  barrier();

  for(uint i=laneID; i<SLICE_SZ; i+=NumThreads) {
    uvec2 at = uvec2(i%SLICE_SIZE.x, i/SLICE_SIZE.x);
    const uvec4 aabb = nodeBbox[at.x][at.y];

    at &= uint(~7u);
    atomicMin(nodeBbox[at.x][at.y].x, aabb.x);
    atomicMin(nodeBbox[at.x][at.y].y, aabb.y);
    atomicMax(nodeBbox[at.x][at.y].z, aabb.z);
    atomicMax(nodeBbox[at.x][at.y].w, aabb.w);
    }
  barrier();

  for(uint i=laneID; i<SLICE_SZ; i+=NumThreads) {
    ivec2 at = ivec2(i%SLICE_SIZE.x, i/SLICE_SIZE.x);
    if(at.x%8!=0 || at.y%8!=0)
      continue;

    const uvec4 aabb = nodeBbox[at.x][at.y];
    at += ivec2(gl_WorkGroupID.xy)*SLICE_SIZE;
    const ivec2 l0 = at/8;

    bvh.nodes[1+(l0.x + l0.y*8)].self = orderedUintToFloat(aabb);
    bvh.nodes[0].aabb[l0.x + l0.y*8]  = orderedUintToFloat(aabb);
    bvh.nodes[0].ptr [l0.x + l0.y*8]  = aabb.z==0 ? 0 : ((l0.x + l0.y*8 + 1) | BVH_BoxNode);
    }

  if(gl_GlobalInvocationID.xy==uvec2(0))
    bvh.nodes[0].self = uintBitsToFloat(sceneBbox);
  }

void main() {
  const uint laneID = gl_LocalInvocationIndex;

  const uint SLICE_SZ = SLICE_SIZE.x*SLICE_SIZE.y;
  for(uint i=laneID; i<SLICE_SZ; i+=NumThreads) {
    nodeBins[i%SLICE_SIZE.x][i/SLICE_SIZE.x] = 0;
    nodeBbox[i%SLICE_SIZE.x][i/SLICE_SIZE.x] = uvec4(0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
    }
  sceneBbox = uvec4(0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
  barrier();

  processMeshlets(1, pos.data[0]);
  barrier();

  processStore(1, pos.data[0]);
  //barrier();

  const ivec2 offset = ivec2(gl_WorkGroupID.xy)*SLICE_SIZE;
  for(uint i=laneID; i<SLICE_SZ; i+=NumThreads) {
    const uint v = nodeBins[i%SLICE_SIZE.x][i/SLICE_SIZE.x];
    imageStore(dbg, offset+ivec2(i%SLICE_SIZE.x, i/SLICE_SIZE.x), uvec4(v));
    }
  }
