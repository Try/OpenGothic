#version 450

#extension GL_GOOGLE_include_directive    : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_samplerless_texture_functions : enable
#extension GL_EXT_control_flow_attributes : enable
// bindless
#extension GL_EXT_nonuniform_qualifier : enable
// #extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
// #extension GL_KHR_memory_scope_semantics : enable

#include "common.glsl"
#include "scene.glsl"
#include "rtsm/rtsm_common.glsl"

layout(local_size_x = 32, local_size_y = 32) in; //fixme: too big wg

const uint NumThreads = gl_WorkGroupSize.x*gl_WorkGroupSize.y*gl_WorkGroupSize.z;

layout(push_constant, std430) uniform UboPush {
  vec3  originLwc;
  float znear;
  } push;
layout(binding = 0)         uniform  utexture2D lightTiles;
layout(binding = 1, std140) uniform  UboScene   { SceneDesc scene; };
layout(binding = 2)         uniform  utexture2D gbufNormal;
layout(binding = 3)         uniform  texture2D  depth;
layout(binding = 4, std430)          buffer Pos { uint  alloc; uint    data[]; } pos;
layout(binding = 5, std430) readonly buffer Lbo { LightSource lights[];        };
layout(binding = 6, std430) readonly buffer VId { uvec4 count; LightId data[]; } vLights;
layout(binding = 7)         uniform  utexture2D meshBinsOmni;
layout(binding = 8, rg32ui) uniform  uimage2D   primTiles;

#if defined(DEBUG_IMG)
layout(binding = 9, r32ui)  uniform  uimage2D   dbgImage;
#endif

shared uint dbgCounter;
void imageDbg(uint info) {
#if defined(DEBUG_IMG)
  imageStore(dbgImage, ivec2(gl_WorkGroupID.xy), uvec4(info));
#endif
  }

#include "rtsm/rtsm_scratch.glsl"
// #include "rtsm/rtsm_omni_bboxes.glsl"

shared uint numLights;
shared uint numPrimitives;
shared uint primitives[2048];

shared uint lightsBinPtr, primListPtr;

ivec2 fragCoord = ivec2(gl_GlobalInvocationID.xy);

uvec2 pullTileData() {
  return texelFetch(lightTiles, ivec2((gl_WorkGroupID.xy*RTSM_SMALL_TILE)/RTSM_LIGHT_TILE), 0).xy;
  }

void storeBin(ivec2 at, uint ptr, uint num) {
  if(gl_LocalInvocationIndex!=0)
    return;
  if(num==0)
    ptr = NULL;
  imageStore(primTiles, at, uvec4(ptr,num,0,0));
  }

uint packPrimitiveId(uint meshlet, uint prim) {
  return (meshlet << 8) | prim;
  }

bool lightIntensity(const vec3 normal, const float distance, const vec3 ldir, const float lrange) {
  const float distanceSquare = (distance * distance);
  if(distanceSquare >= lrange * lrange)
    return false;
  if(-dot(ldir,normal) <= 0)
    return false;
  return true;
  }

// ray related
vec3 rayOrigin(ivec2 frag, float depth) {
  const vec2 fragCoord = ((frag.xy+0.5)*scene.screenResInv)*2.0 - vec2(1.0);
  const vec4 scr       = vec4(fragCoord.x, fragCoord.y, depth, 1.0);
  const vec4 wpos      = scene.viewProjectLwcInv * scr;
  return wpos.xyz/wpos.w;
  }

// visibility
shared uint  cubeFaces;
shared uvec4 bbox[6];
shared vec3  frustum[6][4];

void rayBboxses(const vec3 ray, bool activeRay) {
  const uint laneID = gl_LocalInvocationIndex;

  cubeFaces = 0;
  if(laneID<bbox.length())
    bbox[laneID] = uvec4(0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
  barrier();

  const uint face = rayToFace(ray);
  if(activeRay)
    atomicOr(cubeFaces, 1u<<face);
  barrier();

  if(activeRay) {
    const uint id = face;
    const vec3 rf = rayToFace(ray, face);
    atomicMin(bbox[id].x, floatToOrderedUint(rf.x));
    atomicMin(bbox[id].y, floatToOrderedUint(rf.y));
    atomicMax(bbox[id].z, floatToOrderedUint(rf.x));
    atomicMax(bbox[id].w, floatToOrderedUint(rf.y));
    }
  barrier();

  if(laneID<bbox.length() && (cubeFaces & (1 << laneID))!=0) {
    uvec4 aabb = bbox[laneID];
    if(aabb.x==aabb.z || aabb.y==aabb.w) {
      // degenerated bbox
      atomicAnd(cubeFaces, ~(1 << laneID));
      } else {
      const vec4 aabb = orderedUintToFloat(aabb);
      bbox[laneID] = floatBitsToUint(aabb);

      const uint face = laneID;
      const vec3 fa   = faceToRay(vec2(aabb.xy), face);
      const vec3 fb   = faceToRay(vec2(aabb.zy), face);
      const vec3 fc   = faceToRay(vec2(aabb.zw), face);
      const vec3 fd   = faceToRay(vec2(aabb.xw), face);

      frustum[face][0] = cross(fa, fb);
      frustum[face][1] = cross(fb, fc);
      frustum[face][2] = cross(fc, fd);
      frustum[face][3] = cross(fd, fa);
      }
    }
  }

bool isPrimitiveVisible(vec3 a, vec3 b, vec3 c, uint face) {
  const vec3 p0 = frustum[face][0];
  const vec3 p1 = frustum[face][1];
  const vec3 p2 = frustum[face][2];
  const vec3 p3 = frustum[face][3];

  if(dot(a, p0)<0 && dot(b, p0)<0 && dot(c, p0)<0)
    return false;
  if(dot(a, p1)<0 && dot(b, p1)<0 && dot(c, p1)<0)
    return false;
  if(dot(a, p2)<0 && dot(b, p2)<0 && dot(c, p2)<0)
    return false;
  if(dot(a, p3)<0 && dot(b, p3)<0 && dot(c, p3)<0)
    return false;
  return true;
  }

bool isPrimitiveVisible(vec3 a, vec3 b, vec3 c) {
  for(uint face=0; face<bbox.length(); ++face) {
    if((cubeFaces & (1u << face))==0)
      continue;
    if(isPrimitiveVisible(a, b, c, face))
      return true;
    }
  return false;
  }

bool isPrimitiveVisible(const uint ptr, const uint primId, const LightSource src) {
  uint ptrM = ptr;

  ptrM += MeshletHeaderSize;
  const uvec3 tri = pullPrimitive(ptrM, primId);

  ptrM += MaxPrim;
  const vec3  a   = pullVertex(ptrM, tri.x) - src.pos;
  const vec3  b   = pullVertex(ptrM, tri.y) - src.pos;
  const vec3  c   = pullVertex(ptrM, tri.z) - src.pos;

  vec4 plane;
  plane.xyz = /*normalize*/(cross(b - a, c - a));
  plane.w   = dot(plane.xyz, a);

  const float dist = -plane.w;
  if(dist<0)// || dist>src.range)
    return false;

  if(!isPrimitiveVisible(a, b, c))
    return false;

  return true;
  }

void processMeshletPrimitives(const uint ptr, const uint primCount, const uint primId, const LightSource src) {
  if(primId>=primCount)
    return;

  if(!isPrimitiveVisible(ptr, primId, src))
    return;

  atomicAdd(dbgCounter, 1);
  const uint id = atomicAdd(numPrimitives, 1);
  if(id<primitives.length()) {
    primitives[id] = packPrimitiveId(ptr, primId);
    }
  }

void processPrimitives(const uint tilePtr, const uint maxMeshlets, const LightSource src) {
  const uint  laneID      = gl_LocalInvocationIndex;
  const uint  primPerStep = 32;
  const uint  meshPerStep = NumThreads / primPerStep;

  numPrimitives = 0;
  barrier();

  for(uint i=(laneID/primPerStep); i<maxMeshlets; i+=meshPerStep) {
    const uint laneMs  = laneID % primPerStep;
    const uint ptr     = pos.data[tilePtr + i];
    const uint primCnt = pullPrimitiveCount(ptr);
    const vec4 sp      = pullMeshSphere(ptr);

    for(uint r=laneMs; r<MaxPrim; r+=primPerStep)
      processMeshletPrimitives(ptr, primCnt, r, src);
    }
  }

void processLight(const vec3 wpos, const vec3 normal, const LightId lId, const uint maxMeshlets) {
  const uint laneID = gl_LocalInvocationIndex;

  const LightSource src      = lights[lId.id];
  const uint        tilePtr  = lId.ptr;
  const vec3        distance = wpos-src.pos;

  const float       tMax     = length(distance);
  const vec3        ldir     = distance/tMax;
  bool              lpow     = lightIntensity(normal, tMax, ldir, src.range);

  rayBboxses(ldir, lpow);
  barrier();

  if(cubeFaces==0)
    return;

  processPrimitives(tilePtr, maxMeshlets, src);
  barrier();

  if(laneID==0) {
    if(numPrimitives>=primitives.length())
      numPrimitives = 0;
    primListPtr = allocScratch(numPrimitives);

    const uint idx = atomicAdd(numLights, 1);
    pos.data[lightsBinPtr + idx*4 + 0] = lId.id;
    pos.data[lightsBinPtr + idx*4 + 1] = primListPtr;
    pos.data[lightsBinPtr + idx*4 + 2] = numPrimitives;
    }
  barrier();

  if(primListPtr==NULL)
    return;
  for(uint i=laneID; i<numPrimitives; i+=NumThreads)
    pos.data[primListPtr + i] = primitives[i];
  }

void main() {
  const uint  laneID  = gl_LocalInvocationIndex;
  const uvec2 tile    = pullTileData();
  const uint  lptr    = tile.x;
  const uint  nLights = tile.y;

  if(nLights==0) {
    storeBin(ivec2(gl_WorkGroupID.xy), NULL, 0);
    imageDbg(0);
    return;
    }

  if(laneID==0)
    lightsBinPtr = allocScratch(nLights*4);

  dbgCounter = 0;
  numLights  = 0;
  numPrimitives = 0; //debug
  barrier();

  const ivec2 size   = textureSize(depth, 0);
  const bool  valid  = all(lessThan(fragCoord, size));

  const vec3  normal = valid ? normalFetch(gbufNormal, fragCoord) : vec3(0);
  const float z      = valid ? texelFetch(depth, fragCoord, 0).x  : 1.0;
  const vec3  origin = rayOrigin(fragCoord.xy, z) + (normal*NormalBias) + push.originLwc;

  for(uint i=0; i<nLights; ++i) {
    const uint id          = pos.data[lptr + i];
    const uint numMeshlets = texelFetch(meshBinsOmni, ivec2(id,0), 0).x;

    processLight(origin, normal, vLights.data[id], numMeshlets);
    barrier(); //NOTE: no need
    }

  storeBin(ivec2(gl_WorkGroupID.xy), lightsBinPtr, numLights);
  imageDbg(dbgCounter);
  //imageDbg(numLights);
  }
