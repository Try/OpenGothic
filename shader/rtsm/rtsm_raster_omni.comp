#version 450

#extension GL_GOOGLE_include_directive    : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_samplerless_texture_functions : enable
#extension GL_EXT_control_flow_attributes : enable
// bindless
#extension GL_EXT_nonuniform_qualifier : enable
// #extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
// #extension GL_KHR_memory_scope_semantics : enable

#include "common.glsl"
#include "scene.glsl"
#include "rtsm/rtsm_common.glsl"

#define TRANSLUCENCY 1

layout(local_size_x = 16, local_size_y = 16) in;

const uint NumThreads = gl_WorkGroupSize.x*gl_WorkGroupSize.y*gl_WorkGroupSize.z;

layout(push_constant, std430) uniform UboPush {
  vec3  originLwc;
  } push;
layout(binding = 0, r11f_g11f_b10f) uniform  image2D    outputImage;
layout(binding = 1, std140) uniform  UboScene   { SceneDesc scene; };
layout(binding = 2)         uniform  utexture2D gbufNormal;
layout(binding = 3)         uniform  texture2D  depth;
layout(binding = 4, std430) readonly buffer Pos { uint  alloc; uint    data[]; } pos;
layout(binding = 5, std430) readonly buffer Lbo { LightSource lights[];        };
layout(binding = 6, std430) readonly buffer VId { uvec4 count; LightId data[]; } vLights;
layout(binding = 7)         uniform  utexture2D primBinsOmni;

layout(binding = 9, r32ui)  uniform  uimage2D   dbgImage;

void imageDbg(uint info) {
#if defined(DEBUG_IMG)
  imageStore(dbgImage, ivec2(gl_WorkGroupID.xy), uvec4(info));
#endif
  }

#define CONST_SCRATCH 1
#include "rtsm/rtsm_scratch.glsl"

const float minOpacity = 0.49/255.0;

ivec2 fragCoord = ivec2(gl_GlobalInvocationID.xy);
vec3  light     = vec3(0);

uint primCnt = 0; //counter

shared uint visBits;

uint checkFlatPlane(float a) {
  uint ret = 0;
  if(a<0)
    ret |= 0x1;
  if(a>0)
    ret |= 0x2;
  return ret;
  }

uint primitiveVisibilityBits(const vec3 a) {
  uint ret = 0;
  ret |= checkFlatPlane(a.x) << 0;
  ret |= checkFlatPlane(a.y) << 2;
  ret |= checkFlatPlane(a.z) << 4;
  return ret;
  }

vec3 rayTriangleTest(const vec3 origin, const vec3 raydir, const vec3 v0, const vec3 v1, const vec3 v2) {
  const vec3  e1    = v1 - v0;
  const vec3  e2    = v2 - v0;
  const vec3  s1    = cross(raydir, e2 );
  const float denom = dot( s1, e1 );

  if(denom <= 0.0)
    return vec3(-1);    // This ray is parallel to this triangle.

  const float invDemom = 1.0 / denom;
  const vec3  d = origin - v0;
  vec2  b;
  b.x = dot( d, s1 ) * invDemom;

  vec3 s2 = cross( d, e1 );
  b.y     = dot(raydir, s2 ) * invDemom;

  float t0 = dot(e2, s2) * invDemom;

  if(( b.x < 0.0f ) || ( b.x > 1.0f ) || ( b.y < 0.0f ) || ( b.x + b.y > 1.0f )) {
    return vec3(-1);
    }

  return vec3(t0, b);
  }

float lightIntensity(const vec3 normal, const float distance, const vec3 ldir, const float lrange) {
  const float distanceSquare = (distance * distance);
  const float factor         = distanceSquare / (lrange * lrange);
  const float smoothFactor   = max(1.0 - factor * factor, 0.0);
  if(factor>1.0)
    return 0;

  float lambert = max(0.0,-dot(ldir,normal));
  float lx      = (lambert/max(factor, 0.05)) * (smoothFactor*smoothFactor);
  return lx * Fd_Lambert * 0.1;
  }

const  uint  MaxChunk = NumThreads/2;
shared vec3  meshVertices   [MaxChunk*3];
shared uint  meshVertexUV   [MaxChunk*3];
shared uint  primitiveBucket[MaxChunk];
shared uint  numLocalPrim;

void pullPrimitives(const uint pkg) {
  const uint  laneID = gl_LocalInvocationIndex;

  const uint  ptr  = (pkg >> 8);
  const uint  pId  = pkg & 0xFF;
  const uvec4 tri  = pullPrimitiveFull(ptr+MeshletHeaderSize, pId);
  const uint  ptrV = ptr + MeshletHeaderSize + MaxPrim;

  const uint  id       = atomicAdd(numLocalPrim, 1);
  primitiveBucket[id]  = packUint2x16(uvec2(tri.w, pullMeshBucketId(ptr)));

  //FIXME: register pressure
  meshVertices[id*3+0] = pullVertex(ptrV, tri.x);
  meshVertices[id*3+1] = pullVertex(ptrV, tri.y);
  meshVertices[id*3+2] = pullVertex(ptrV, tri.z);

  meshVertexUV[id*3+0] = pullVertexUV(ptrV, tri.x);
  meshVertexUV[id*3+1] = pullVertexUV(ptrV, tri.y);
  meshVertexUV[id*3+2] = pullVertexUV(ptrV, tri.z);
  }

shared uint inactiveRays;
float rasterBatch(const vec3 origin, const vec3 dir, const float tMax, float opacity) {
  const float tMin = 15;

  const uint laneID = gl_LocalInvocationIndex;
  if(opacity<=minOpacity)
    return opacity;

  for(uint id=0; id<numLocalPrim; ++id) {
    const vec3  a = meshVertices[id*3+0];
    const vec3  b = meshVertices[id*3+1];
    const vec3  c = meshVertices[id*3+2];
    const vec3  t = rayTriangleTest(origin, dir, a, b, c);
    if(!(tMin<t.x && t.x<tMax))
      continue;
    opacity = 0;
    break;
    }

  return opacity;
  }

bool earlyOut() {
  return inactiveRays==NumThreads;
  }

float tracePacket(const uvec2 tileHeader, const vec3 origin, const vec3 dir, const float tMax, float opacity) {
  const uint  laneID        = gl_LocalInvocationIndex;
  const uint  numPrimitives = tileHeader.y & 0xFFFF;
  const uint  steps         = (numPrimitives + MaxChunk - 1)/MaxChunk;

  inactiveRays = 0;
  visBits      = 0;
  barrier();

  if(opacity<=minOpacity)
    atomicAdd(inactiveRays, 1); else
    atomicOr(visBits, primitiveVisibilityBits(dir));
  barrier();

  for(uint s=0; s<numPrimitives; s+=MaxChunk) {
    if(earlyOut())
      break;

    numLocalPrim = 0;
    barrier();
    const uint i = s + laneID;
    if(i<numPrimitives && laneID<MaxChunk) {
      const uint mask = pos.data[tileHeader.x + i*2 + 0];
      const uint ptr  = pos.data[tileHeader.x + i*2 + 1];
      if((mask & visBits)!=0)
        pullPrimitives(ptr);
      }
    barrier();

    primCnt += numLocalPrim;
    opacity = rasterBatch(origin, dir, tMax, opacity);
    barrier();
    }

  if(opacity<=minOpacity)
    return 0;
  return opacity;
  }

void processLight(const vec3 origin, const vec3 normal, const LightId lId, const uint numMeshlets) {
  const LightSource src      = lights[lId.id];
  const uint        tilePtr  = lId.ptr;
  const vec3        distance = origin-src.pos;

  const float       tMax     = length(distance);
  const vec3        ldir     = distance/tMax;
  float             lpow     = lightIntensity(normal, tMax, ldir, src.range);

  lpow = tracePacket(uvec2(tilePtr, numMeshlets), src.pos, ldir, tMax-1, lpow);

  light += vec3(lpow * src.color);
  }

vec3 worldPos(ivec2 frag, float depth) {
  const vec2 fragCoord = ((frag.xy+0.5)*scene.screenResInv)*2.0 - vec2(1.0);
  const vec4 scr       = vec4(fragCoord.x, fragCoord.y, depth, 1.0);
  const vec4 wpos      = scene.viewProjectLwcInv * scr;
  return wpos.xyz/wpos.w;
  }

void main() {
  const ivec2 size   = textureSize(depth, 0);
  const bool  valid  = all(lessThan(fragCoord, size));

  const vec3  normal = valid ? normalFetch(gbufNormal, fragCoord) : vec3(0);
  const float z      = valid ? texelFetch(depth, fragCoord, 0).x  : 1.0;

  const vec3  origin = worldPos(fragCoord.xy, z) + (normal*NormalBias) + push.originLwc;

  if(vLights.count.x>0) {
    //TODO: many lights
    const uint numMeshlets = texelFetch(primBinsOmni, ivec2(0,0), 0).x;
    processLight(origin, normal, vLights.data[0], numMeshlets);
    }

  if(valid)
    imageStore(outputImage, ivec2(fragCoord), vec4(light, 1));
  imageDbg(primCnt);
  }
