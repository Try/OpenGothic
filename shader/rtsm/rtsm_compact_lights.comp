#version 450

#extension GL_GOOGLE_include_directive    : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_samplerless_texture_functions : enable
#extension GL_EXT_control_flow_attributes : enable

#include "common.glsl"
#include "scene.glsl"
#include "rtsm/rtsm_common.glsl"

layout(local_size_x = 512) in;

const uint NumThreads = gl_WorkGroupSize.x*gl_WorkGroupSize.y*gl_WorkGroupSize.z;

layout(push_constant, std430) uniform UboPush {
  vec3  originLwc;
  float znear;
  } push;
layout(binding = 0)         uniform  utexture2D lightTiles;
layout(binding = 1, std140) uniform  UboScene   { SceneDesc scene; };

layout(binding = 4, std430)          buffer Pos { uint  alloc; uint    data[]; } pos;
layout(binding = 5, std430) readonly buffer Lbo { LightSource lights[];        };
layout(binding = 6, std430) readonly buffer VId { uvec4 count; LightId data[]; } vLights;
layout(binding = 7, std430)          buffer PId { uvec4 count; LightId data[]; } pLights;


shared uint bits[NumThreads/32];
shared uint numLights, wPtr;

uint firstLight = gl_WorkGroupID.x*NumThreads;

uvec2 pullTileData(ivec2 at) {
  return texelFetch(lightTiles, at, 0).xy;
  }

void processTile(ivec2 at) {
  const uvec2 tile    = pullTileData(at);
  const uint  lptr    = tile.x;
  const uint  nLights = tile.y;

  for(uint i=0; i<nLights; ++i) {
    const uint lId = pos.data[lptr + i*sizeof_Light + 0];
    // const uint  planeBits = pos.data[lptr + i*sizeof_Light + 1];
    if(!(firstLight<=lId && lId<firstLight+bits.length()*32))
      continue;
    const uint bit = lId - firstLight;
    atomicOr(bits[bit/32], 1u << (bit%32));
    }
  }

void processTiles() {
  const uint  laneID  = gl_LocalInvocationIndex;

  ivec2 size = textureSize(lightTiles, 0);
  uint  num  = size.x*size.y;

  for(uint i=laneID; i<num; i+=NumThreads) {
    processTile(ivec2(i%size.x, i/size.y));
    }
  }

void main() {
  const uint laneID = gl_LocalInvocationIndex;

  numLights = 0;
  for(uint i=laneID; i<bits.length(); i+=NumThreads)
    bits[i] = 0;
  barrier();

  processTiles();
  barrier();

  if(laneID<bits.length())
    atomicAdd(numLights, bitCount(bits[laneID]));
  barrier();

  if(laneID==0)
    wPtr = atomicAdd(pLights.count.x, numLights);
  barrier();

  for(uint i=laneID; i<bits.length()*32; i+=NumThreads) {
    if((bits[i/32] & (1u <<(i%32)))==0)
      continue;
    uint at = atomicAdd(wPtr, 1);

    pLights.data[at].id        = i + firstLight;
    pLights.data[at].aabb_low  = 0;
    pLights.data[at].aabb_high = 0;
    }
  }
