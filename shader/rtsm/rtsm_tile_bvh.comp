#version 450

#extension GL_GOOGLE_include_directive : enable

#include "rtsm/rtsm_common.glsl"
#include "scene.glsl"
#include "common.glsl"

layout(local_size_x = 32, local_size_y = 16) in;

const uint NumThreads = gl_WorkGroupSize.x*gl_WorkGroupSize.y*gl_WorkGroupSize.z;

struct Tile {
  vec4  rayTileBbox[MaxSlices];
  float rayDepthMin[MaxSlices];
  uint  numSlices;
  };

struct LTile {
  Tile subtiles[4*4];
  };

layout(push_constant, std140) uniform UboPush {
  ivec2 numTiles;
  } push;
layout(binding = 0)         uniform texture2D   outputImage;
layout(binding = 1, std140) uniform UboScene    { SceneDesc scene;   };
layout(binding = 2)         uniform texture2D   depth;
layout(binding = 3, std430)         buffer Pos  { uint  alloc; uint data[];  } pos;
layout(binding = 4, std430)         buffer Tbr  { Tile  tiles[]; };

layout(binding = 9, r32ui)  uniform uimage2D           dbgImage;

void imageDbg(ivec2 at, uint info) {
#if defined(DEBUG_IMG)
  imageStore(dbgImage, at, uvec4(info));
#endif
  }

#include "rtsm/rtsm_scratch.glsl"

// tiles: 128 -> 32, 5'576 bytes
#include "rtsm/rtsm_tile_bboxes.glsl"

void main() {
  const uint laneID = gl_LocalInvocationIndex;

  tileBboxes(ivec2(gl_WorkGroupID.xy), RTSM_LARGE_TILE);
  barrier();

  const uint lTile = (gl_WorkGroupID.x + gl_WorkGroupID.y*push.numTiles.x) * rayTileBbox.length();
  for(uint i=laneID; i<rayTileBbox.length(); i+=NumThreads) {
    const uint tileId = i / MaxSlices + lTile;
    const uint slice  = i % MaxSlices;

    tiles[tileId].rayTileBbox[slice] = uintBitsToFloat(rayTileBbox[i]);
    tiles[tileId].rayDepthMin[slice] = uintBitsToFloat(rayDepthMin[i]);
    tiles[tileId].numSlices          = numSlices[tileId];
    }
  }
