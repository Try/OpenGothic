#version 450

#extension GL_GOOGLE_include_directive    : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_samplerless_texture_functions : enable
#extension GL_EXT_control_flow_attributes : enable

#include "common.glsl"
#include "scene.glsl"
#include "rtsm/rtsm_common.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

const uint NumThreads = gl_WorkGroupSize.x*gl_WorkGroupSize.y*gl_WorkGroupSize.z;
const uint sizeof_Light = 1 + 4*6;

layout(push_constant, std430) uniform UboPush {
  vec3  originLwc;
  float znear;
  } push;
layout(binding = 0)         uniform  utexture2D lightTiles;
layout(binding = 1, std140) uniform  UboScene   { SceneDesc scene; };
layout(binding = 2)         uniform  utexture2D gbufNormal;
layout(binding = 3)         uniform  texture2D  depth;
layout(binding = 4, std430)          buffer Pos { uint  alloc; uint    data[]; } pos;
layout(binding = 5, std430) readonly buffer Lbo { LightSource lights[];        };
layout(binding = 6, std430) readonly buffer VId { uvec4 count; LightId data[]; } vLights;

#if defined(DEBUG_IMG)
layout(binding = 9, r32ui)  uniform  uimage2D   dbgImage;
#endif

#include "rtsm/rtsm_scratch.glsl"

ivec2 fragCoord = ivec2(gl_GlobalInvocationID.xy);

uvec2 pullTileData() {
  return texelFetch(lightTiles, ivec2((gl_GlobalInvocationID.xy)/RTSM_LIGHT_TILE), 0).xy;
  }

// ray related
vec3 rayOrigin(ivec2 frag, float depth, vec3 normal) {
  const vec2 fragCoord = ((frag.xy+0.5)*scene.screenResInv)*2.0 - vec2(1.0);
  const vec4 scr       = vec4(fragCoord.x, fragCoord.y, depth, 1.0);
  const vec4 wpos      = scene.viewProjectLwcInv * scr;
  return (wpos.xyz + normal*NormalBias)/wpos.w;
  }

void processLight(const vec3 lpos, const float range, const uint ptr, const vec3 wpos, const vec3 normal, const float z) {
  const vec3        distance = wpos-lpos;
  const float       tMaxQ    = dot(distance,distance);
  const float       rangeQ   = range*range;

  const bool activeRay = tMaxQ<rangeQ && dot(normal, distance)<0;
  if(activeRay) {
    const uint face = rayToFace(distance);
    const vec2 rf   = rayToFace(distance, face);
    const uint fptr = ptr + face*4 + 1;
    atomicMin(pos.data[fptr+0], floatToOrderedUint(rf.x));
    atomicMin(pos.data[fptr+1], floatToOrderedUint(rf.y));
    atomicMax(pos.data[fptr+2], floatToOrderedUint(rf.x));
    atomicMax(pos.data[fptr+3], floatToOrderedUint(rf.y));
    }
  }

const uint MaxLights = 8;

shared uvec4 faces[MaxLights*6];
void fastPath(const uint lptr, const uint nLights) {
  const ivec2 size      = textureSize(depth, 0);
  const bool  valid     = all(lessThan(fragCoord, size));
  const float z         = valid ? texelFetch(depth, fragCoord, 0).x  : 1.0;
  const vec3  normal    = valid ? normalFetch(gbufNormal, fragCoord) : vec3(0);
  const vec3  wpos      = rayOrigin(fragCoord.xy, z, normal) + push.originLwc;

  const uint  laneID  = gl_LocalInvocationIndex;
  if(laneID<nLights*6) {
    faces[laneID] = uvec4(0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
    }
  barrier();

  for(uint i=0; i<nLights; ++i) {
    const uint        ptr = lptr + i*sizeof_Light;
    const uint        lId = pos.data[ptr];
    const LightSource src = lights[lId];

    const vec3        distance = wpos-src.pos;
    const float       tMaxQ    = dot(distance,distance);
    const float       rangeQ   = src.range*src.range;

    const bool activeRay = tMaxQ<rangeQ && dot(normal, distance)<0;
    if(activeRay) {
      const uint face = rayToFace(distance);
      const vec2 rf   = rayToFace(distance, face);
      const uint fptr = i*6 + face;
      atomicMin(faces[fptr].x, floatToOrderedUint(rf.x));
      atomicMin(faces[fptr].y, floatToOrderedUint(rf.y));
      atomicMax(faces[fptr].z, floatToOrderedUint(rf.x));
      atomicMax(faces[fptr].w, floatToOrderedUint(rf.y));
      }
    }
  barrier();

  if(laneID<nLights*6) {
    const uvec4 fc   = faces[laneID];
    if(fc==uvec4(0xFFFFFFFF, 0xFFFFFFFF, 0, 0))
      return;
    const uint  i    = laneID/6;
    const uint  face = laneID%6;

    const uint  ptr  = lptr + i*sizeof_Light;
    const uint  fptr = ptr + face*4 + 1;

    atomicMin(pos.data[fptr+0], fc.x);
    atomicMin(pos.data[fptr+1], fc.y);
    atomicMax(pos.data[fptr+2], fc.z);
    atomicMax(pos.data[fptr+3], fc.w);
    }
  }

void main() {
  const uvec2 tile    = pullTileData();
  const uint  lptr    = tile.x;
  const uint  nLights = tile.y;

  if(nLights==0) {
    return;
    }

  if(nLights < MaxLights) {
    fastPath(lptr, nLights);
    return;
    }

  const ivec2 size      = textureSize(depth, 0);
  const bool  valid     = all(lessThan(fragCoord, size));
  if(!valid)
    return;

  const float z         = texelFetch(depth, fragCoord, 0).x;
  if(z>=1.0)
    return;

  const vec3  normal    = normalFetch(gbufNormal, fragCoord);
  const vec3  wpos      = rayOrigin(fragCoord.xy, z, normal) + push.originLwc;

  for(uint i=0; i<nLights; ++i) {
    const uint        ptr = lptr + i*sizeof_Light;
    const uint        lId = pos.data[ptr];
    const LightSource src = lights[lId];
    processLight(src.pos, src.range, ptr, wpos, normal, z);
    }
  }
